```
 _   _ ____  ____    _  _____ _____   ____  _____ _     _____ _____ _____ 
| | | |  _ \|  _ \  / \|_   _| ____| |  _ \| ____| |   | ____|_   _| ____|
| | | | |_) | | | |/ _ \ | | |  _|   | | | |  _| | |   |  _|   | | |  _|  
| |_| |  __/| |_| / ___ \| | | |___  | |_| | |___| |___| |___  | | | |___ 
 \___/|_|   |____/_/   \_\_| |_____| |____/|_____|_____|_____| |_| |_____|
                                                                            
 ____  _____ _     _____ ____ _____                                       
/ ___|| ____| |   | ____/ ___|_   _|                                      
\___ \|  _| | |   |  _|| |     | |                                        
 ___) | |___| |___| |__| |___  | |                                        
|____/|_____|_____|_____\____| |_|                                        
```

**Reading time:** 8 min | **Level:** Intermediate

**Tags:** `sql-injection` `database-security` `postgresql` `cybersecurity` `owasp-top10` 

---

## [+] Introduction

In [Post 1 of this series](/blog/post.html?id=BD-AP3-2025.1-q1), we saw how to create secure tables. But what if the problem isn't in the schema, but in **everyday queries**? Today we'll analyze **Questions 2, 3, and 4 from UFF's Database AP3 2025.1**, involving UPDATE, DELETE, and SELECT. Let's discover how these seemingly innocent operations can become devastating attack vectors.

**Spoiler:** A misplaced comma can delete your entire database.

---

## [+] Context: ML Ensembles System

Recalling the AP3 scenario: we have a system that manages **Machine Learning Ensembles**. Users from different countries create ensembles with specific parameters, and the system trains multiple algorithms (SVM, K-means, Random Forest, etc.).

**Relevant schema:**

```sql
USUARIO(uid, unome, ulogin, uprovedor, uIP, pais)
ALGORITMO(aid, titulo, categoria, tipo, ano)
ENSEMBLE(eid, uid, data_submissao, hora_submissao, num_epocas, 
         tamanho_batch, taxa_aprendizado)
MODELO(eid, aid, acuracia, precisao)
```

---

## [UPDATE] Question 2: Mass Modification

### Original Statement

> _"Present an SQL query to reduce the tamanho_batch parameter of all Ensembles created by Users from Brazil and the United States by 20%. Remember that a 20% reduction means multiplying the current value by 0.8. The query must UPDATE the table. (1.0 point)"_

### Official Answer Key (Corrected and Optimized)

```sql
-- More efficient and secure version
UPDATE ensemble e
SET tamanho_batch = GREATEST(1, (e.tamanho_batch * 0.8)::int)
FROM usuario u
WHERE u.uid = e.uid
  AND u.pais = ANY($1::char(2)[]);  -- e.g., ARRAY['BR','US']
```

**Why this version is better:**

1. `UPDATE ... FROM` is faster than subquery with IN
2. `GREATEST(1, ...)` prevents batch size zero or negative
3. Explicit cast `::int` avoids type ambiguity
4. Uses ISO codes (CHAR(2)) as defined in Post 1
5. Efficiently uses index on `ensemble(uid)`

**Seems safe?** Not quite. Let's see the problem.

### [!] Vulnerability: UPDATE Injection

**Scenario:** Web application allows admin to filter by country before applying adjustments.

```python
# [X] VULNERABLE CODE (DON'T DO THIS!)
def reduce_batch_by_country(selected_countries):
    # selected_countries comes from form: "Brazil, United States"
    
    query = f"""
        UPDATE ENSEMBLE
        SET tamanho_batch = tamanho_batch * 0.8
        WHERE uid IN (
            SELECT uid FROM USUARIO
            WHERE pais IN ({selected_countries})
        )
    """
    
    cursor.execute(query)  # DANGER!
```

**Attack 1: Universal Modification**

```python
# Attacker sends:
selected_countries = "'BR') OR '1'='1' --"

# Resulting query:
"""
UPDATE ENSEMBLE
SET tamanho_batch = tamanho_batch * 0.8
WHERE uid IN (
    SELECT uid FROM USUARIO
    WHERE pais IN ('BR') OR '1'='1' --')
)
"""
# Result: ALL ensembles are updated!
```

> **[!] IMPORTANT:** The problem is **string concatenation**, not the use of IN!

**Attack 2: Destructive Modification**

```python
# Attacker sends:
selected_countries = "'Brazil'); UPDATE ENSEMBLE SET tamanho_batch = 0; --"
# Result: Zeros ALL tamanho_batch!
```

**Attack 3: Data Exfiltration via UPDATE (side-channel)**

```python
# Attacker uses UPDATE to discover sensitive data
# by observing how many records were affected
```

### [OK] Fix: Prepared Statements + Protections

```python
# [+] SECURE CODE with additional protections
def reduce_batch_by_country(countries_list):
    # countries_list = ['BR', 'US']  # ISO-3166-1 alpha-2
    
    # Input validation
    valid_countries = ['BR', 'US', 'AR', 'CL', 'MX', 'CO']
    filtered_countries = [c for c in countries_list if c in valid_countries]
    
    if not filtered_countries:
        raise ValueError("No valid countries provided")
    
    with connection.cursor() as cursor:
        # BEGIN with safety timeouts
        cursor.execute("BEGIN")
        cursor.execute("SET LOCAL statement_timeout = '5s'")
        cursor.execute("SET LOCAL lock_timeout = '2s'")
        
        try:
            # Parameterized prepared statement
            query = """
                UPDATE ensemble e
                SET tamanho_batch = GREATEST(1, (e.tamanho_batch * 0.8)::int)
                FROM usuario u
                WHERE u.uid = e.uid
                  AND u.pais = ANY(%s)
                RETURNING e.eid
            """
            
            cursor.execute(query, (filtered_countries,))
            affected = cursor.rowcount
            
            # Safety check: abort if too large
            if affected > 10000:
                cursor.execute("ROLLBACK")
                raise Exception(f"Attempting to update {affected} records! Aborted.")
            
            logger.info(f"Updated {affected} ensembles from countries: {filtered_countries}")
            cursor.execute("COMMIT")
            return affected
            
        except Exception as e:
            cursor.execute("ROLLBACK")
            raise
```

---

## [DELETE] Question 3: The Dangerous Deletion

### Original Statement

> _"Present an SQL query that deletes Algorithms that have never been used in any Ensemble. (1.0 point)"_

### Official Answer Key (Corrected)

```sql
-- [+] Uses NOT EXISTS (avoids NULL trap)
DELETE FROM ALGORITMO a
WHERE NOT EXISTS (
    SELECT 1 FROM MODELO m WHERE m.aid = a.aid
)
RETURNING a.aid, a.titulo;
```

**Why NOT EXISTS is better than NOT IN:**

```
┌─────────────────────────────────┐
│     NOT EXISTS vs NOT IN        │
├─────────────────────────────────┤
│ • NULL-safe                     │
│ • Faster (short-circuit)        │
│ • Clearer semantics             │
└─────────────────────────────────┘
```

> **[!] Warning:** If MODELO table is empty, deletes ALL algorithms!

### [X] Vulnerability: DELETE Injection

```python
# [X] VULNERABLE CODE
def clean_unused_algorithms(category_filter=None):
    base_query = "DELETE FROM ALGORITMO WHERE aid NOT IN (SELECT DISTINCT aid FROM MODELO)"
    
    if category_filter:
        query = f"{base_query} AND categoria = '{category_filter}'"
    else:
        query = base_query
    
    cursor.execute(query)  # DANGER!
```

**Attack 1: Total Deletion**

```python
category_filter = "' OR '1'='1"
# Result: ALL algorithms deleted!
```

**Attack 2: Selective Malicious Deletion**

```python
category_filter = "supervised' OR aid IN (SELECT aid FROM ALGORITMO WHERE titulo LIKE 'K-%')"
# Deletes K-means, K-NN, etc. (malicious competition)
```

### [OK] Fix: Validation + Transaction + Protection

```python
# [+] SECURE CODE with multiple protections
def clean_unused_algorithms(category=None):
    valid_categories = ['supervised', 'unsupervised', 'reinforcement']
    
    # Strict validation
    if category and category not in valid_categories:
        raise ValueError(f"Invalid category: {category}")
    
    with connection.cursor() as cursor:
        cursor.execute("BEGIN")
        
        try:
            # Protection: abort if MODELO is empty
            cursor.execute("SELECT COUNT(*) FROM MODELO")
            model_count = cursor.fetchone()[0]
            if model_count == 0:
                raise Exception("Aborted: MODELO empty - would delete ALL algorithms!")
            
            # Parameterized query with NOT EXISTS
            if category:
                query = """
                    DELETE FROM ALGORITMO a
                    WHERE NOT EXISTS (
                        SELECT 1 FROM MODELO m WHERE m.aid = a.aid
                    )
                    AND a.categoria = %s
                    RETURNING a.aid, a.titulo
                """
                cursor.execute(query, (category,))
            else:
                query = """
                    DELETE FROM ALGORITMO a
                    WHERE NOT EXISTS (
                        SELECT 1 FROM MODELO m WHERE m.aid = a.aid
                    )
                    RETURNING a.aid, a.titulo
                """
                cursor.execute(query)
            
            deleted = cursor.fetchall()
            
            # Safety check
            if len(deleted) > 100:
                cursor.execute("ROLLBACK")
                raise Exception(f"Suspicious mass deletion ({len(deleted)} records)!")
            
            cursor.execute("COMMIT")
            return deleted
            
        except Exception as e:
            cursor.execute("ROLLBACK")
            raise
```

---

## [SELECT] Question 4: Silent Extraction

### Original Statement

> _"Present an SQL query that lists the names of Users who never created Ensembles that include Models based on the K-means Algorithm. (2.0 points)"_

### Official Answer Key (Corrected and Optimized)

```sql
-- [+] Uses NOT EXISTS + indexes + LIMIT
SELECT u.unome
FROM USUARIO u
WHERE NOT EXISTS (
    SELECT 1
    FROM ENSEMBLE e
    JOIN MODELO m ON m.eid = e.eid
    JOIN ALGORITMO a ON a.aid = m.aid
    WHERE e.uid = u.uid
      AND a.titulo = $1
)
ORDER BY u.unome
LIMIT 500;  -- Prevents gigantic payloads
```

**Problem:** SELECT seems harmless, but it's the #1 vector for data exfiltration!

### [!] Vulnerability: SELECT Injection

```python
# [X] VULNERABLE CODE
def find_users_without_algorithm(algorithm_name):
    query = f"""
        SELECT unome
        FROM USUARIO
        WHERE uid NOT IN (
            SELECT DISTINCT e.uid
            FROM ENSEMBLE e
            JOIN MODELO m ON e.eid = m.eid
            JOIN ALGORITMO a ON m.aid = a.aid
            WHERE a.titulo = '{algorithm_name}'
        )
    """
    
    cursor.execute(query)
    return cursor.fetchall()
```

**Attack 1: UNION Injection - Exfiltrate Credentials**

```python
algorithm_name = "K-means' UNION SELECT ulogin || ':' || uprovedor FROM USUARIO --"

# Result returned:
# maria
# joao
# admin:gmail.com  <-- DATA LEAKED!
# root:company.com <-- DATA LEAKED!
```

**Attack 2: Boolean-Based Blind Injection**

```python
# Attacker extracts data character by character
algorithm_name = "K-means' AND SUBSTRING((SELECT uprovedor FROM USUARIO WHERE uid=1), 1, 1) = 'g' AND '1'='1"
```

**Attack 3: Time-Based Blind Injection**

```python
# Attacker uses pg_sleep() to exfiltrate data via timing
algorithm_name = """
K-means' AND (
    SELECT CASE 
        WHEN SUBSTRING(uprovedor, 1, 1) = 'g' 
        THEN pg_sleep(5) 
        ELSE pg_sleep(0) 
    END 
    FROM USUARIO WHERE uid = 1
) IS NOT NULL AND '1'='1
"""
```

### [OK] Fix: Parameterization + Whitelist + Indexes

```python
# [+] SECURE CODE
def find_users_without_algorithm(algorithm_name):
    # 1. Validation: does algorithm exist?
    with connection.cursor() as cursor:
        cursor.execute(
            "SELECT COUNT(*) FROM ALGORITMO WHERE titulo = %s",
            (algorithm_name,)
        )
        if cursor.fetchone()[0] == 0:
            raise ValueError(f"Algorithm '{algorithm_name}' not found")
    
    # 2. Prepared statement with NOT EXISTS
    query = """
        SELECT u.unome
        FROM USUARIO u
        WHERE NOT EXISTS (
            SELECT 1
            FROM ENSEMBLE e
            JOIN MODELO m ON m.eid = e.eid
            JOIN ALGORITMO a ON a.aid = m.aid
            WHERE e.uid = u.uid
              AND a.titulo = %s
        )
        ORDER BY u.unome
        LIMIT 500
    """
    
    cursor.execute(query, (algorithm_name,))
    return cursor.fetchall()
```

---

## [*] Real Case: Sony Pictures Hack (2014)

In 2014, Sony Pictures suffered one of the biggest attacks in history. **Multiple vectors** were identified, including **SQL Injection in reporting queries**:

```
┌─────────────────────────────────────┐
│         SONY PICTURES HACK          │
├─────────────────────────────────────┤
│ • SELECT injection → DB mapping     │
│ • UNION injection → 47k credentials │
│ • UPDATE injection → altered logs   │
│ • Time-based blind → exfiltration   │
│                                     │
│ DAMAGE: $100 million                │
└─────────────────────────────────────┘
```

**Lesson:** Simple SELECT/UPDATE/DELETE queries are powerful weapons in the wrong hands.

---

## [-] Django/ORM: The False Sense of Security

**Myth:** "I use Django ORM, I'm protected against SQL Injection!"

**Reality:** You're protected... _most of the time_.

### Cases Where Django ORM Fails

#### 1. `.raw()` and `.extra()`

```python
# [X] VULNERABLE even in Django!
algorithm_name = request.GET.get('algorithm')
users = Usuario.objects.raw(
    f"SELECT * FROM usuario WHERE titulo = '{algorithm_name}'"
)

# [OK] Fix:
users = Usuario.objects.raw(
    "SELECT * FROM usuario WHERE titulo = %s",
    [algorithm_name]
)
```

#### 2. String Interpolation in Annotations

```python
# [X] VULNERABLE
from django.db.models import RawSQL
field = request.GET.get('field')
Ensemble.objects.annotate(
    value=RawSQL(f"SELECT {field} FROM ensemble", [])
)
```

---

## [=] Checklist: How NOT to Be the Next Victim

```
┌─────────────────────────────────────────┐
│       SECURITY CHECKLIST v2.0           │
├─────────────────────────────────────────┤
│                 UPDATE                  │
│ [ ] Uses prepared statements?           │
│ [ ] Validates values against whitelist? │
│ [ ] Has safety check (limit records)?   │
│ [ ] Uses transaction with rollback?     │
│ [ ] Log records who and how many?       │
│                                         │
│                 DELETE                  │
│ [ ] NEVER executes DELETE without WHERE │
│ [ ] Uses RETURNING for audit?           │
│ [ ] Double confirmation for mass?       │
│ [ ] Soft delete instead of hard?        │
│ [ ] Recent backup available?            │
│                                         │
│                 SELECT                  │
│ [ ] Parameterizes ALL inputs?           │
│ [ ] Limits results (LIMIT)?             │
│ [ ] Doesn't expose structure in errors? │
│ [ ] Doesn't return extra sensitive data?│
│ [ ] Rate limiting against brute force?  │
└─────────────────────────────────────────┘
```

---

## [>] Additional Resources

Read the original [AP3 exam](assets/BD-AP3-2025.1.pdf) for context and its [official answer key](assets/BD-AP3-2025.1-gabarito.pdf)

### Testing Tools

- **SQLMap** - Automates SQL Injection detection (use ONLY on your own systems!)
- **OWASP ZAP** - Vulnerability scanner
- **Burp Suite** - Intercepts and modifies requests

### Documentation

- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [PostgreSQL Security Best Practices](https://www.postgresql.org/docs/current/security.html)
- [Django Security Documentation](https://docs.djangoproject.com/en/stable/topics/security/)

### Academic Papers

- Su, Z. & Wassermann, G. (2006). "The Essence of Command Injection Attacks"
- Medeiros, I. et al. (2016). "Automatic Detection of SQL Injection Vulnerabilities"

---

## [>>] Next Steps

**Next in series:** [Post 3 - Normalization and Integrity](/blog/post.html?id=BD-AP3-2025.1-q5-q8)

**Previous in series:** [Post 1 - Schema Design = Security Design](/blog/post.html?id=BD-AP3-2025.1-q1)

---

```
┌──────────────────────────────────────────────────┐
│ Author: Beatriz Costa                            │
│ Series: Cybersecurity Lessons from UFF AP        │
│ Last updated: November 04, 2025                  │
│                                                  │
│ [!] DISCLAIMER: Examples for educational         │
│     purposes only. Testing SQLi on third-party   │
│     systems is a CRIME (Computer Fraud & Abuse)  │
└──────────────────────────────────────────────────┘
```