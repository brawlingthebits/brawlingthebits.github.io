# O Trio Mortal: UPDATE, DELETE e SELECT que Podem Destruir Seu Banco

```
 _   _ ____  ____    _  _____ _____   ____  _____ _     _____ _____ _____ 
| | | |  _ \|  _ \  / \|_   _| ____| |  _ \| ____| |   | ____|_   _| ____|
| | | | |_) | | | |/ _ \ | | |  _|   | | | |  _| | |   |  _|   | | |  _|  
| |_| |  __/| |_| / ___ \| | | |___  | |_| | |___| |___| |___  | | | |___ 
 \___/|_|   |____/_/   \_\_| |_____| |____/|_____|_____|_____| |_| |_____|
                                                                            
 ____  _____ _     _____ ____ _____                                       
/ ___|| ____| |   | ____/ ___|_   _|                                      
\___ \|  _| | |   |  _|| |     | |                                        
 ___) | |___| |___| |__| |___  | |                                        
|____/|_____|_____|_____\____| |_|                                        
```

**Tempo de leitura:** 8 min | **Nível:** Intermediário

**Tags:** `sql-injection` `database-security` `postgresql` `cybersecurity` `owasp-top10` 

---

## [+] Introdução

No [Post 1 desta série](/blog/post.html?id=BD-AP3-2025.1-q1), vimos como criar tabelas seguras. Mas e se o problema não está no schema, mas nas **queries do dia a dia**? Hoje vamos analisar as **Questões 2, 3 e 4 da AP3 2025.1** da UFF, que envolvem UPDATE, DELETE e SELECT. Vamos descobrir como essas operações aparentemente inocentes podem se transformar em vetores de ataque devastadores.

**Spoiler:** Uma vírgula no lugar errado pode deletar seu banco inteiro.

---

## [+] Contexto: Sistema de ML Ensembles

Relembrando o cenário da AP3: temos um sistema que gerencia **Ensembles de Machine Learning**. Usuários de diferentes países criam ensembles com parâmetros específicos, e o sistema treina múltiplos algoritmos (SVM, K-means, Random Forest, etc.).

**Schema relevante:**

```sql
USUARIO(uid, unome, ulogin, uprovedor, uIP, país)
ALGORITMO(aid, titulo, categoria, tipo, ano)
ENSEMBLE(eid, uid, data_submissao, hora_submissao, num_epocas, 
         tamanho_batch, taxa_aprendizado)
MODELO(eid, aid, acuracia, precisao)
```

---

## [UPDATE] Questão 2: A Modificação em Massa

### Enunciado Original

> _"Apresente uma consulta em SQL para reduzir o valor do parâmetro tamanho_batch de todos os Ensembles criados por Usuários do Brasil e dos Estados Unidos em 20%. Lembre-se que uma redução de 20% significa multiplicar o valor atual por 0,8. A consulta deve ATUALIZAR a tabela. (1,0 ponto)"_

### Gabarito Oficial (Corrigido e Otimizado)

```sql
-- Versão mais eficiente e segura
UPDATE ensemble e
SET tamanho_batch = GREATEST(1, (e.tamanho_batch * 0.8)::int)
FROM usuario u
WHERE u.uid = e.uid
  AND u.pais = ANY($1::char(2)[]);  -- ex: ARRAY['BR','US']
```

**Por que essa versão é melhor:**

1. `UPDATE ... FROM` é mais rápido que subquery com IN
2. `GREATEST(1, ...)` previne batch size zero ou negativo
3. Cast explícito `::int` evita ambiguidade de tipo
4. Usa códigos ISO (CHAR(2)) como definido no Post 1
5. Usa o índice em `ensemble(uid)` eficientemente

**Parece seguro?** Nem tanto. Vamos ver o problema.

### [!] Vulnerabilidade: UPDATE Injection

**Cenário:** Aplicação web permite admin filtrar por país antes de aplicar ajustes.

```python
# [X] CÓDIGO VULNERÁVEL (NÃO FAÇA ISSO!)
def reduzir_batch_por_pais(paises_selecionados):
    # paises_selecionados vem do formulário: "Brasil, Estados Unidos"
    
    query = f"""
        UPDATE ENSEMBLE
        SET tamanho_batch = tamanho_batch * 0.8
        WHERE uid IN (
            SELECT uid FROM USUARIO
            WHERE pais IN ({paises_selecionados})
        )
    """
    
    cursor.execute(query)  # PERIGO!
```

**Ataque 1: Modificação Universal**

```python
# Atacante envia:
paises_selecionados = "'BR') OR '1'='1' --"

# Query resultante:
"""
UPDATE ENSEMBLE
SET tamanho_batch = tamanho_batch * 0.8
WHERE uid IN (
    SELECT uid FROM USUARIO
    WHERE pais IN ('BR') OR '1'='1' --')
)
"""
# Resultado: TODOS os ensembles são atualizados!
```

> **[!] IMPORTANTE:** O problema é a **concatenação de strings**, não o uso de IN!

**Ataque 2: Modificação Destrutiva**

```python
# Atacante envia:
paises_selecionados = "'Brasil'); UPDATE ENSEMBLE SET tamanho_batch = 0; --"
# Resultado: Zera TODOS os tamanho_batch!
```

**Ataque 3: Exfiltração via UPDATE (side-channel)**

```python
# Atacante usa UPDATE para descobrir dados sensíveis
# observando quantos registros foram afetados
```

### [OK] Correção: Prepared Statements + Proteções

```python
# [+] CÓDIGO SEGURO com proteções adicionais
def reduzir_batch_por_pais(paises_list):
    # paises_list = ['BR', 'US']  # ISO-3166-1 alpha-2
    
    # Validação de entrada
    paises_validos = ['BR', 'US', 'AR', 'CL', 'MX', 'CO']
    paises_filtrados = [p for p in paises_list if p in paises_validos]
    
    if not paises_filtrados:
        raise ValueError("Nenhum país válido fornecido")
    
    with connection.cursor() as cursor:
        # BEGIN com timeouts de segurança
        cursor.execute("BEGIN")
        cursor.execute("SET LOCAL statement_timeout = '5s'")
        cursor.execute("SET LOCAL lock_timeout = '2s'")
        
        try:
            # Prepared statement parametrizado
            query = """
                UPDATE ensemble e
                SET tamanho_batch = GREATEST(1, (e.tamanho_batch * 0.8)::int)
                FROM usuario u
                WHERE u.uid = e.uid
                  AND u.pais = ANY(%s)
                RETURNING e.eid
            """
            
            cursor.execute(query, (paises_filtrados,))
            affected = cursor.rowcount
            
            # Safety check: aborta se muito grande
            if affected > 10000:
                cursor.execute("ROLLBACK")
                raise Exception(f"Tentativa de atualizar {affected} registros! Abortado.")
            
            logger.info(f"Atualizados {affected} ensembles de países: {paises_filtrados}")
            cursor.execute("COMMIT")
            return affected
            
        except Exception as e:
            cursor.execute("ROLLBACK")
            raise
```

---

## [DELETE] Questão 3: A Exclusão Perigosa

### Enunciado Original

> _"Apresente uma consulta em SQL que exclua os Algoritmos que nunca foram usados em nenhum Ensemble. (1,0 ponto)"_

### Gabarito Oficial (Corrigido)

```sql
-- [+] Usa NOT EXISTS (evita NULL trap)
DELETE FROM ALGORITMO a
WHERE NOT EXISTS (
    SELECT 1 FROM MODELO m WHERE m.aid = a.aid
)
RETURNING a.aid, a.titulo;
```

**Por que NOT EXISTS é melhor que NOT IN:**

```
┌─────────────────────────────────┐
│     NOT EXISTS vs NOT IN        │
├─────────────────────────────────┤
│ • NULL-safe                     │
│ • Mais rápido (short-circuit)   │
│ • Semântica mais clara          │
└─────────────────────────────────┘
```

> **[!] Cuidado:** Se tabela MODELO estiver vazia, deleta TODOS os algoritmos!

### [X] Vulnerabilidade: DELETE Injection

```python
# [X] CÓDIGO VULNERÁVEL
def limpar_algoritmos_nao_usados(categoria_filtro=None):
    base_query = "DELETE FROM ALGORITMO WHERE aid NOT IN (SELECT DISTINCT aid FROM MODELO)"
    
    if categoria_filtro:
        query = f"{base_query} AND categoria = '{categoria_filtro}'"
    else:
        query = base_query
    
    cursor.execute(query)  # PERIGO!
```

**Ataque 1: Deleção Total**

```python
categoria_filtro = "' OR '1'='1"
# Resultado: TODOS os algoritmos deletados!
```

**Ataque 2: Deleção Seletiva Maliciosa**

```python
categoria_filtro = "supervisionado' OR aid IN (SELECT aid FROM ALGORITMO WHERE titulo LIKE 'K-%')"
# Deleta K-means, K-NN, etc. (competição maliciosa)
```

### [OK] Correção: Validação + Transação + Proteção

```python
# [+] CÓDIGO SEGURO com múltiplas proteções
def limpar_algoritmos_nao_usados(categoria=None):
    categorias_validas = ['supervised', 'unsupervised', 'reinforcement']
    
    # Validação estrita
    if categoria and categoria not in categorias_validas:
        raise ValueError(f"Categoria inválida: {categoria}")
    
    with connection.cursor() as cursor:
        cursor.execute("BEGIN")
        
        try:
            # Proteção: aborta se MODELO está vazia
            cursor.execute("SELECT COUNT(*) FROM MODELO")
            modelo_count = cursor.fetchone()[0]
            if modelo_count == 0:
                raise Exception("Abortado: MODELO vazia - deletaria TODOS os algoritmos!")
            
            # Query parametrizada com NOT EXISTS
            if categoria:
                query = """
                    DELETE FROM ALGORITMO a
                    WHERE NOT EXISTS (
                        SELECT 1 FROM MODELO m WHERE m.aid = a.aid
                    )
                    AND a.categoria = %s
                    RETURNING a.aid, a.titulo
                """
                cursor.execute(query, (categoria,))
            else:
                query = """
                    DELETE FROM ALGORITMO a
                    WHERE NOT EXISTS (
                        SELECT 1 FROM MODELO m WHERE m.aid = a.aid
                    )
                    RETURNING a.aid, a.titulo
                """
                cursor.execute(query)
            
            deletados = cursor.fetchall()
            
            # Safety check
            if len(deletados) > 100:
                cursor.execute("ROLLBACK")
                raise Exception(f"Deleção em massa suspeita ({len(deletados)} registros)!")
            
            cursor.execute("COMMIT")
            return deletados
            
        except Exception as e:
            cursor.execute("ROLLBACK")
            raise
```

---

## [SELECT] Questão 4: A Extração Silenciosa

### Enunciado Original

> _"Apresente uma consulta em SQL que liste os nomes dos Usuários que nunca criaram Ensembles que incluam Modelos baseados no Algoritmo de nome K-means. (2,0 pontos)"_

### Gabarito Oficial (Corrigido e Otimizado)

```sql
-- [+] Usa NOT EXISTS + índices + LIMIT
SELECT u.unome
FROM USUARIO u
WHERE NOT EXISTS (
    SELECT 1
    FROM ENSEMBLE e
    JOIN MODELO m ON m.eid = e.eid
    JOIN ALGORITMO a ON a.aid = m.aid
    WHERE e.uid = u.uid
      AND a.titulo = $1
)
ORDER BY u.unome
LIMIT 500;  -- Previne payloads gigantes
```

**Problema:** SELECT parece inofensivo, mas é o vetor #1 de exfiltração de dados!

### [!] Vulnerabilidade: SELECT Injection

```python
# [X] CÓDIGO VULNERÁVEL
def buscar_usuarios_sem_algoritmo(nome_algoritmo):
    query = f"""
        SELECT unome
        FROM USUARIO
        WHERE uid NOT IN (
            SELECT DISTINCT e.uid
            FROM ENSEMBLE e
            JOIN MODELO m ON e.eid = m.eid
            JOIN ALGORITMO a ON m.aid = a.aid
            WHERE a.titulo = '{nome_algoritmo}'
        )
    """
    
    cursor.execute(query)
    return cursor.fetchall()
```

**Ataque 1: UNION Injection - Exfiltrar Credenciais**

```python
nome_algoritmo = "K-means' UNION SELECT ulogin || ':' || uprovedor FROM USUARIO --"

# Resultado retornado:
# maria
# joao
# admin:gmail.com  <-- DADOS VAZADOS!
# root:company.com <-- DADOS VAZADOS!
```

**Ataque 2: Boolean-Based Blind Injection**

```python
# Atacante extrai dados caractere por caractere
nome_algoritmo = "K-means' AND SUBSTRING((SELECT uprovedor FROM USUARIO WHERE uid=1), 1, 1) = 'g' AND '1'='1"
```

**Ataque 3: Time-Based Blind Injection**

```python
# Atacante usa pg_sleep() para exfiltrar dados via timing
nome_algoritmo = """
K-means' AND (
    SELECT CASE 
        WHEN SUBSTRING(uprovedor, 1, 1) = 'g' 
        THEN pg_sleep(5) 
        ELSE pg_sleep(0) 
    END 
    FROM USUARIO WHERE uid = 1
) IS NOT NULL AND '1'='1
"""
```

### [OK] Correção: Parametrização + Whitelist + Índices

```python
# [+] CÓDIGO SEGURO
def buscar_usuarios_sem_algoritmo(nome_algoritmo):
    # 1. Validação: algoritmo existe?
    with connection.cursor() as cursor:
        cursor.execute(
            "SELECT COUNT(*) FROM ALGORITMO WHERE titulo = %s",
            (nome_algoritmo,)
        )
        if cursor.fetchone()[0] == 0:
            raise ValueError(f"Algoritmo '{nome_algoritmo}' não encontrado")
    
    # 2. Prepared statement com NOT EXISTS
    query = """
        SELECT u.unome
        FROM USUARIO u
        WHERE NOT EXISTS (
            SELECT 1
            FROM ENSEMBLE e
            JOIN MODELO m ON m.eid = e.eid
            JOIN ALGORITMO a ON a.aid = m.aid
            WHERE e.uid = u.uid
              AND a.titulo = %s
        )
        ORDER BY u.unome
        LIMIT 500
    """
    
    cursor.execute(query, (nome_algoritmo,))
    return cursor.fetchall()
```

---

## [*] Caso Real: Sony Pictures Hack (2014)

Em 2014, a Sony Pictures sofreu um dos maiores ataques da história. **Múltiplos vetores** foram identificados, incluindo **SQL Injection em queries de relatórios**:

```
┌─────────────────────────────────────┐
│         SONY PICTURES HACK          │
├─────────────────────────────────────┤
│ • SELECT injection -> mapeamento DB │
│ • UNION injection -> 47k credenciais│
│ • UPDATE injection -> logs alterados│
│ • Time-based blind -> exfiltração   │
│                                     │
│ DANO: $100 milhões                  │
└─────────────────────────────────────┘
```

**Lição:** Queries simples de SELECT/UPDATE/DELETE são armas poderosas nas mãos erradas.

---

## [-] Django/ORM: A Falsa Sensação de Segurança

**Mito:** "Uso Django ORM, estou protegido contra SQL Injection!"

**Realidade:** Você está protegido... _na maioria das vezes_.

### Casos Onde Django ORM Falha

#### 1. `.raw()` e `.extra()`

```python
# [X] VULNERÁVEL mesmo no Django!
nome_algoritmo = request.GET.get('algoritmo')
usuarios = Usuario.objects.raw(
    f"SELECT * FROM usuario WHERE titulo = '{nome_algoritmo}'"
)

# [OK] Correção:
usuarios = Usuario.objects.raw(
    "SELECT * FROM usuario WHERE titulo = %s",
    [nome_algoritmo]
)
```

#### 2. String Interpolation em Annotations

```python
# [X] VULNERÁVEL
from django.db.models import RawSQL
campo = request.GET.get('campo')
Ensemble.objects.annotate(
    valor=RawSQL(f"SELECT {campo} FROM ensemble", [])
)
```

---

## [=] Checklist: Como NÃO Ser a Próxima Vítima

```
┌─────────────────────────────────────────┐
│          SECURITY CHECKLIST v2.0        │
├─────────────────────────────────────────┤
│                 UPDATE                  │
│ [ ] Usa prepared statements?            │
│ [ ] Valida valores contra whitelist?    │
│ [ ] Tem safety check (limite registros)?│
│ [ ] Usa transação com rollback?         │
│ [ ] Log registra quem e quantos?        │
│                                         │
│                 DELETE                  │
│ [ ] NUNCA executa DELETE sem WHERE      │
│ [ ] Usa RETURNING para auditoria?       │
│ [ ] Confirmação dupla para massa?       │
│ [ ] Soft delete ao invés de hard?       │
│ [ ] Backup recente disponível?          │
│                                         │
│                 SELECT                  │
│ [ ] Parametriza TODOS os inputs?        │
│ [ ] Limita resultados (LIMIT)?          │
│ [ ] Não expõe estrutura em erros?       │
│ [ ] Não retorna dados sensíveis extras? │
│ [ ] Rate limiting contra brute force?   │
└─────────────────────────────────────────┘
```

---

## [>] Recursos Adicionais

Leia a [prova AP3 original](assets/BD-AP3-2025.1.pdf) para contexto e seu [gabarito oficial](assets/BD-AP3-2025.1-gabarito.pdf)

### Ferramentas de Teste

- **SQLMap** - Automatiza detecção de SQL Injection (use APENAS em seus sistemas!)
- **OWASP ZAP** - Scanner de vulnerabilidades
- **Burp Suite** - Intercepta e modifica requests

### Documentação

- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [PostgreSQL Security Best Practices](https://www.postgresql.org/docs/current/security.html)
- [Django Security Documentation](https://docs.djangoproject.com/en/stable/topics/security/)

### Papers Acadêmicos

- Su, Z. & Wassermann, G. (2006). "The Essence of Command Injection Attacks"
- Medeiros, I. et al. (2016). "Automatic Detection of SQL Injection Vulnerabilities"

---

## [>>] Próximos Passos

**Próximo da série:** [Post 3 - Normalização e Integridade](/blog/post.html?id=BD-AP3-2025.1-q5-q8)

**Anterior na série:** [Post 1 - Schema Design = Security Design](/blog/post.html?id=BD-AP3-2025.1-q1)

---

```
┌──────────────────────────────────────────────────┐
│ Autor: Beatriz Costa                             │
│ Série: Cybersecurity Lessons from UFF AP         │
│ Última atualização: 04 de novembro de 2025       │
│                                                  │
│ [!] DISCLAIMER: Exemplos apenas educativos.      │
│     Testar SQLi em sistemas de terceiros é       │
│     CRIME (Lei 12.737/2012 - Carolina Dieckmann) │
└──────────────────────────────────────────────────┘
```
