# Schema Design = Security Design: Lessons from UFF's Database AP3 2025.1

```
 ____   ____ _   _ _____ __  __    _    
/ ___| |  _ \ | | | ____|  \/  |  / \   
\___ \ | |_) | |_| |  _| | |\/| | / _ \  
 ___) |  __/|  _  | |___| |  | |/ ___ \ 
|____/|_|   |_| |_|_____|_|  |_/_/   \_\
                                         
 ____  _____ ____ _   _ ____  ___ _______   __
/ ___|| ____/ ___| | | |  _ \|_ _|_   _\ \ / /
\___ \|  _|| |   | | | | |_) || |  | |  \ V / 
 ___) | |__| |___| |_| |  _ < | |  | |   | |  
|____/|_____\____|\___/|_| \_\___| |_|   |_|  
```

**Reading time:** 7-9 min | **Level:** Beginner/Intermediate

**Tags:** `database-security` `sql-security` `schema-design` `postgresql` `cybersecurity` 

---

## [+] Introduction

How you design SQL tables can decide whether your system stays safe or leaks crown-jewel data. This post reviews **AP3 2025.1 (UFF) - Question 1**, which asks for a schema to manage **Machine Learning Ensembles** - and turns it into a **data security playbook**.

---

## [+] Question Context

**Given logical schema:**

```sql
USUARIO(uid, unome, ulogin, uprovedor, uIP, pais)
ALGORITMO(aid, titulo, categoria, tipo, ano)
ENSEMBLE(eid, uid, data_submissao, hora_submissao, num_epocas, 
         tamanho_batch, taxa_aprendizado)
MODELO(eid, aid, acuracia, precisao)
```

Why it matters: sensitive identifiers (logins, IPs) and **intellectual property** (model configs/metrics). The schema is the **first line of defense**.

---

## [>] Base Version (answer-key style)

> Good for teaching; **insufficient** for production.

```sql
CREATE TABLE USUARIO (
  uid INT PRIMARY KEY,
  unome VARCHAR(100),
  ulogin VARCHAR(50),
  uprovedor VARCHAR(50),
  uIP VARCHAR(45),
  pais VARCHAR(50)
);

CREATE TABLE ALGORITMO (
  aid INT PRIMARY KEY,
  titulo VARCHAR(100),
  categoria VARCHAR(50),
  tipo VARCHAR(50),
  ano INT
);

CREATE TABLE ENSEMBLE (
  eid INT PRIMARY KEY,
  uid INT,
  data_submissao DATE,
  hora_submissao TIME,
  num_epocas INT,
  tamanho_batch INT,
  taxa_aprendizado DECIMAL(5,4),
  FOREIGN KEY (uid) REFERENCES USUARIO(uid)
);

CREATE TABLE MODELO (
  eid INT,
  aid INT,
  acuracia DECIMAL(5,4),
  precisao DECIMAL(5,4),
  PRIMARY KEY (eid, aid),
  FOREIGN KEY (eid) REFERENCES ENSEMBLE(eid),
  FOREIGN KEY (aid) REFERENCES ALGORITMO(aid)
);
```

---

## [>>] Hardened Version (production-ready)

```
┌─────────────────────────────────────┐
│    SECURITY ENHANCEMENTS            │
├─────────────────────────────────────┤
│ • inet for IPs (native validation)  │
│ • citext for case-insensitive login │
│ • timestamptz for timezone-aware    │
│ • IDENTITY instead of SERIAL        │
│ • percent_0_1 domain for metrics    │
│ • pais as CHAR(2) ISO-3166          │
│ • Consistent NOT NULL + CHECK       │
│ • Focused indexes                   │
│ • Audit triggers                    │
│ • Optional RLS (multi-tenant)       │
└─────────────────────────────────────┘
```

```sql
-- Useful extensions
CREATE EXTENSION IF NOT EXISTS citext;

-- Reusable domain for [0,1]
CREATE DOMAIN percent_0_1 AS numeric(5,4)
  CHECK (VALUE >= 0 AND VALUE <= 1);

-- USERS
CREATE TABLE usuario (
  uid        BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  unome      varchar(100) NOT NULL CHECK (char_length(unome) >= 3),
  ulogin     citext NOT NULL UNIQUE CHECK (ulogin ~ '^[a-z0-9_]{3,50}$'),
  uprovedor  varchar(50) NOT NULL,
  uip        inet NOT NULL,
  pais       char(2) NOT NULL CHECK (pais ~ '^[A-Z]{2}$'),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- ALGORITHMS
CREATE TABLE algoritmo (
  aid        BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  titulo     varchar(100) NOT NULL UNIQUE,
  categoria  text NOT NULL
    CHECK (categoria IN ('supervised','unsupervised','reinforcement')),
  tipo       varchar(50) NOT NULL,
  ano        smallint NOT NULL
    CHECK (ano BETWEEN 1950 AND EXTRACT(YEAR FROM now())::int),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- ENSEMBLES
CREATE TABLE ensemble (
  eid              BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  uid              BIGINT NOT NULL REFERENCES usuario(uid) ON DELETE CASCADE,
  submitted_at     timestamptz NOT NULL DEFAULT now(),
  num_epocas       int NOT NULL CHECK (num_epocas BETWEEN 1 AND 10000),
  tamanho_batch    int NOT NULL CHECK (tamanho_batch BETWEEN 1 AND 10000),
  taxa_aprendizado percent_0_1 NOT NULL,
  created_at       timestamptz NOT NULL DEFAULT now(),
  updated_at       timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS ix_ensemble_uid          ON ensemble(uid);
CREATE INDEX IF NOT EXISTS ix_ensemble_submitted_at ON ensemble(submitted_at);

-- MODELS
CREATE TABLE modelo (
  eid        BIGINT NOT NULL REFERENCES ensemble(eid)  ON DELETE CASCADE,
  aid        BIGINT NOT NULL REFERENCES algoritmo(aid) ON DELETE RESTRICT,
  acuracia   percent_0_1,
  precisao   percent_0_1,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (eid, aid)
);

CREATE INDEX IF NOT EXISTS ix_modelo_aid ON modelo(aid);

-- Auto-update updated_at
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END; $$;

CREATE TRIGGER tg_usuario_upd   BEFORE UPDATE ON usuario  FOR EACH ROW EXECUTE FUNCTION set_updated_at();
CREATE TRIGGER tg_algoritmo_upd BEFORE UPDATE ON algoritmo FOR EACH ROW EXECUTE FUNCTION set_updated_at();
CREATE TRIGGER tg_ensemble_upd  BEFORE UPDATE ON ensemble  FOR EACH ROW EXECUTE FUNCTION set_updated_at();
CREATE TRIGGER tg_modelo_upd    BEFORE UPDATE ON modelo    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- (Optional) RLS: each user sees only their own ensembles/models
ALTER TABLE ensemble ENABLE ROW LEVEL SECURITY;
ALTER TABLE modelo   ENABLE ROW LEVEL SECURITY;

CREATE POLICY ensemble_owner
  ON ensemble
  USING (uid = current_setting('app.current_uid', true)::bigint)
  WITH CHECK (uid = current_setting('app.current_uid', true)::bigint);

CREATE POLICY modelo_owner
  ON modelo
  USING (EXISTS (
    SELECT 1 FROM ensemble e
    WHERE e.eid = modelo.eid
      AND e.uid = current_setting('app.current_uid', true)::bigint
  ));
```

> **[!]** Indexes improve performance and help resilience under load, but they are **not** DoS controls on their own. Combine with rate limits, timeouts, and circuit breakers.

---

## [-] "But I use Django/ORM..."

Great - but **app validation does not replace database constraints**.

### Model with app-level validation AND DB hardening

```python
# models.py
from django.db import models
from django.core.validators import RegexValidator, MinLengthValidator
from django.contrib.postgres.fields import CICharField  # -> citext

class Usuario(models.Model):
    unome = models.CharField(max_length=100, validators=[MinLengthValidator(3)])
    ulogin = CICharField(
        max_length=50,
        unique=True,
        validators=[RegexValidator(r'^[a-z0-9_]{3,50}$', message='Invalid login')]
    )
    uIP = models.GenericIPAddressField(protocol='both', unpack_ipv4=True)
    pais = models.CharField(max_length=2)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
```

**Hardening migration (DB-level):**

```python
# migrations/0002_db_constraints.py
from django.db import migrations

HARDEN = """
CREATE EXTENSION IF NOT EXISTS citext;
ALTER TABLE app_usuario
  ALTER COLUMN "uIP"  TYPE inet USING "uIP"::inet,
  ALTER COLUMN "pais" TYPE char(2) USING upper("pais");
ALTER TABLE app_usuario
  ADD CONSTRAINT chk_unome_len CHECK (char_length("unome") >= 3),
  ADD CONSTRAINT chk_pais_code CHECK ("pais" ~ '^[A-Z]{2}$');
"""

REVERT = """
ALTER TABLE app_usuario DROP CONSTRAINT IF EXISTS chk_unome_len;
ALTER TABLE app_usuario DROP CONSTRAINT IF EXISTS chk_pais_code;
-- (Revert types only if necessary)
"""

class Migration(migrations.Migration):
    dependencies = [('app', '0001_initial')]
    operations = [migrations.RunSQL(HARDEN, REVERT)]
```

> **[OK]** Defense in depth: the ORM protects UX and business rules; the DB enforces minimum invariants against raw SQL, legacy jobs, and direct access.

---

## [X] Ethical Attack Simulations (revised)

### 1) Unbounded input → Oversized payload / DoS

**Symptom:** `VARCHAR` without limits + no app validation.

```sql
CREATE TABLE usuario_vuln (
  uid BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  unome varchar,  -- no limit
  ulogin varchar,
  uip    text
);

INSERT INTO usuario_vuln(unome, ulogin, uip)
VALUES (repeat('A', 1000000), 'attacker', '192.168.1.1');
```

**Impact:** memory/storage pressure, expensive vacuums, slow scans.  
**Fix:** size limits + app validation.

### 2) SQL Injection (root cause = string concatenation)

Constraints don't stop SQLi; **only parameterization** does. Use prepared statements, ORM, bind parameters. Keep constraints for **data quality**.

### 3) Critical NULL fields

Set `NOT NULL` and proper defaults; avoid ghost users/ensembles.

### 4) Orphan references

Always use `FOREIGN KEY` with appropriate policy (`CASCADE`, `RESTRICT`).

---

## [*] "Kaggle 2017" Case (Fictional/Didactic)

**Fictional scenario for teaching purposes.** Example shows how missing limits and constraints can break audits and expose metadata.

---

## [=] Schema Security Checklist

```
┌──────────────────────────────────────┐
│  SCHEMA SECURITY CHECKLIST v1.0      │
├──────────────────────────────────────┤
│ [ ] Right types (inet, citext, etc)  │
│ [ ] NOT NULL on essentials           │
│ [ ] CHECK (ranges, regex, ISO-3166)  │
│ [ ] VARCHAR with sensible sizes      │
│ [ ] FKs with proper ON DELETE policy │
│ [ ] Indexes for common joins/filters │
│ [ ] Audit (created_at, updated_at)   │
│ [ ] RLS/Privileges per tenant/role   │
│ [ ] Comments (COMMENT ON) docs       │
└──────────────────────────────────────┘
```

---

## [>] Additional Resources

### Documentation

- [PostgreSQL: CREATE TABLE Documentation](https://www.postgresql.org/docs/current/sql-createtable.html)
- [PostgreSQL: Data Types](https://www.postgresql.org/docs/current/datatype.html)
- [PostgreSQL: Constraints](https://www.postgresql.org/docs/current/ddl-constraints.html)

### Security Standards

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [CWE-89: SQL Injection](https://cwe.mitre.org/data/definitions/89.html)

### Books

- "SQL Antipatterns" by Bill Karwin
- "Database Reliability Engineering" by Laine Campbell & Charity Majors

---

## [>>] Next Steps

**Next in series:** [Post 2 - The Deadly Trio: UPDATE, DELETE, SELECT](/blog/post.html?id=BD-AP3-2025.1-q2-q4)

**Practice safely:**

- Use [DB Fiddle](https://www.db-fiddle.com/) to test PostgreSQL schemas
- Try [SQLFiddle](http://sqlfiddle.com/) for experimenting with constraints
- Set up a local PostgreSQL instance with Docker: `docker run -p 5432:5432 postgres:16`
- Read the original [AP3 exam](assets/BD-AP3-2025.1.pdf) for context and its [official answer key](assets/BD-AP3-2025.1-gabarito.pdf)

---

```
┌──────────────────────────────────────────────────┐
│ Author: Beatriz Costa                            │
│ Series: Cybersecurity Lessons from UFF AP        │
│ Last updated: November 04, 2025                  │
│                                                  │
│ [!] Educational purposes only                    │
└──────────────────────────────────────────────────┘
```