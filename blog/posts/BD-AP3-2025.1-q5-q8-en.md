```
 _   _  ___  ____  __  __    _    _     ___ _____  _  _____ ___ ___  _   _ 
| \ | |/ _ \|  _ \|  \/  |  / \  | |   |_ _|__  / / \|_   _|_ _/ _ \| \ | |
|  \| | | | | |_) | |\/| | / _ \ | |    | |  / / / _ \ | |  | | | | |  \| |
| |\  | |_| |  _ <| |  | |/ ___ \| |___ | | / /_/ ___ \| |  | | |_| | |\  |
|_| \_|\___/|_| \_\_|  |_/_/   \_\_____|___/____/_/   \_\_| |___\___/|_| \_|
                                                                              
 ____    _  _____  _       ___ _   _ _____ _____ ____ ____  ___ _______   __
|  _ \  / \|_   _|/ \     |_ _| \ | |_   _| ____/ ___|  _ \|_ _|_   _\ \ / /
| | | |/ _ \ | | / _ \     | ||  \| | | | |  _|| |  _| |_) || |  | |  \ V / 
| |_| / ___ \| |/ ___ \    | || |\  | | | | |__| |_| |  _ < | |  | |   | |  
|____/_/   \_\_/_/   \_\  |___|_| \_| |_| |_____\____|_| \_\___| |_|   |_|  
```

**Reading time:** 10 min | **Level:** Intermediate/Advanced

**Tags:** `database-normalization` `functional-dependencies` `group-by-injection` `data-integrity` `relational-algebra` 

---

## [+] Introduction

In previous posts, we saw how to create secure schemas and protect basic queries. Today we dive into **Questions 5-8 from AP3 2025.1**, exploring how **poor normalization** and **unprotected aggregations** can expose your system to fraud, inconsistencies, and sophisticated attacks.

**Spoiler:** A misconfigured GROUP BY can reveal the entire company's salary data.

---

## [GROUP BY] Question 5: Aggregations and Data Leakage

### Original Statement

> _"Consider the relation DOCENTE(SIAPE, NOME, UF, SALARIO, NIVEL) that stores UFF faculty data, where SIAPE is the primary key of DOCENTE. Present an SQL query that shows the average salaries of faculty by level, but only when the average is greater than 5,000 and the levels are ASSOCIADO and TITULAR. (1.0 point)"_

### Official Answer Key

```sql
SELECT nivel, AVG(salario) AS media_salarial
FROM DOCENTE
WHERE nivel IN ('ASSOCIADO', 'TITULAR')
GROUP BY nivel
HAVING AVG(salario) > 5000;
```

**Security Analysis:**

```
┌──────────────────────────────────────┐
│        GROUP BY RISKS                │
├──────────────────────────────────────┤
│ • Statistical inference              │
│ • Timing attacks on aggregations     │
│ • Resource exhaustion (GROUP BY ALL) │
│ • Information disclosure via HAVING  │
└──────────────────────────────────────┘
```

### [!] Vulnerability: GROUP BY Information Disclosure

**Scenario:** System allows custom HR queries.

```python
# [X] VULNERABLE CODE
def salary_report(selected_levels, average_limit):
    query = f"""
        SELECT nivel, AVG(salario), COUNT(*) as total
        FROM DOCENTE
        WHERE nivel IN ({selected_levels})
        GROUP BY nivel
        HAVING AVG(salario) > {average_limit}
    """
    return cursor.execute(query).fetchall()
```

**Attack 1: Individual Salary Inference**

```python
# Attacker breaks list context to add conditions
levels = "'TITULAR') AND SIAPE = 12345 OR nivel IN ('TITULAR'"

# Resulting query:
"""
WHERE nivel IN ('TITULAR') AND SIAPE = 12345 OR nivel IN ('TITULAR')
"""
# If COUNT(*) = 1, the AVG() reveals exact salary!
```

**Attack 2: Resource Exhaustion**

```python
# Attacker forces GROUP BY on high cardinality field
levels = "'TITULAR') GROUP BY SIAPE, NOME, UF, SALARIO --"

# Creates thousands of groups, consuming memory
```

**Attack 3: Blind Injection via HAVING**

```python
# Attacker uses HAVING to extract data
average_limit = "5000 OR EXISTS (SELECT 1 FROM DOCENTE WHERE SALARIO > 100000)"

# Based on results, discovers if salary > 100k exists
```

### [OK] Fix: Secure Aggregations

```python
# [+] SECURE CODE with protections
def secure_salary_report(levels, average_limit):
    # 1. Whitelist levels
    valid_levels = {'ASSOCIADO', 'TITULAR', 'ADJUNTO'}
    filtered_levels = [l for l in levels if l in valid_levels]
    
    # 2. Numeric validation
    if not isinstance(average_limit, (int, float)) or average_limit < 0:
        raise ValueError("Invalid limit")
    
    with connection.cursor() as cursor:
        # Security settings
        cursor.execute("BEGIN")
        cursor.execute("SET LOCAL statement_timeout = '2s'")
        cursor.execute("SET LOCAL work_mem = '16MB'")
        
        # 3. Privacy protection - k-anonymity
        cursor.execute("""
            SELECT nivel, COUNT(*) as qty 
            FROM DOCENTE 
            WHERE nivel = ANY(%s)
            GROUP BY nivel
        """, (filtered_levels,))
        
        counts = cursor.fetchall()
        valid_levels = []
        
        for level, qty in counts:
            if qty >= 10:  # k-anonymity threshold = 10
                valid_levels.append(level)
        
        # Rule: need at least 2 valid groups to prevent inference
        if len(valid_levels) < 2:
            raise Exception("Insufficient data to guarantee privacy")
        
        # 4. Parameterized query with protections
        # ANY(%s) accepts array in PostgreSQL - avoids concatenation
        query = """
            SELECT 
                nivel,
                ROUND(AVG(salario)::numeric, -2) as approx_average,  -- Round to hundreds
                CASE 
                    WHEN COUNT(*) < 10 THEN '<10'
                    WHEN COUNT(*) BETWEEN 10 AND 50 THEN '10-50'
                    ELSE '50+'
                END as quantity_range
            FROM DOCENTE
            WHERE nivel = ANY(%s)
            GROUP BY nivel
            HAVING AVG(salario) > %s AND COUNT(*) >= 10
            ORDER BY nivel
            LIMIT 100
        """
        
        cursor.execute(query, (valid_levels, average_limit))
        results = cursor.fetchall()
        cursor.execute("COMMIT")
        
        return results
```

**Implemented Protections:**

1. **K-anonymity (k=10):** Suppress groups with less than 10 records
2. **Small-cell suppression:** Minimum 2 valid groups per query
3. **Statement timeout:** 2-second execution limit
4. **Memory limit:** work_mem limited to 16MB
5. **Rounding:** Averages rounded to prevent exact inference
6. **Parameterization:** ANY(%s) for arrays - never string concatenation

---

## [FD] Question 6: Functional Dependencies and Anomalies

### Original Statement

> _"Let R(A,B,C) be a relation in 1NF. Let A, B, and C be integer attributes. Consider that attribute A forms the primary key of R. Provide a possible instance of R (set of tuples of R), composed of only two tuples, that shows if A → B and A → C are functional dependencies of R, then B → C is not necessarily also a functional dependency of R. (1.0 point)"_

### Answer with Security Analysis

```sql
-- Example instance:
-- A | B | C
-- 1 | 50| 10
-- 2 | 50| 20

-- Analysis:
-- A → B: OK (1→50, 2→50)
-- A → C: OK (1→10, 2→20) 
-- B → C: FAILS! (50→10 AND 50→20)
```

### [!] Why This Matters for Security

```
┌──────────────────────────────────────────┐
│      ANOMALIES WITHOUT NORMALIZATION     │
├──────────────────────────────────────────┤
│ INSERT: Inconsistent data                │
│ UPDATE: Partial changes                  │
│ DELETE: Unintended data loss             │
│                                          │
│ RESULT: Business rule bypass             │
└──────────────────────────────────────────┘
```

**Real Example: Permission System**

```sql
-- [X] POORLY NORMALIZED TABLE
CREATE TABLE user_permissions (
    user_id INT,
    role VARCHAR(50),
    permission VARCHAR(100),
    department VARCHAR(50),
    PRIMARY KEY (user_id, permission)
);

-- Data:
-- user_id | role    | permission      | department
-- 1       | admin   | delete_all      | IT
-- 2       | admin   | delete_all      | HR
-- 3       | viewer  | read_only       | IT

-- PROBLEM: role → permission should be an FD
-- but admin in IT has different permissions than admin in HR!
```

**Attack: Privilege Escalation via Update Anomaly**

```sql
-- Attacker exploits update anomaly
UPDATE user_permissions 
SET role = 'admin' 
WHERE user_id = 3;

-- Now user 3 is 'admin' but keeps 'read_only'
-- System confused: admin or not?
```

### [OK] Solution: Proper Normalization

```sql
-- [+] NORMALIZED SCHEMA (3NF)

-- Users table
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    department VARCHAR(50) NOT NULL
);

-- Roles table
CREATE TABLE roles (
    role_id INT PRIMARY KEY,
    role_name VARCHAR(50) NOT NULL UNIQUE
);

-- Permissions table
CREATE TABLE permissions (
    permission_id INT PRIMARY KEY,
    permission_name VARCHAR(100) NOT NULL UNIQUE
);

-- Role-permission relationship
CREATE TABLE role_permissions (
    role_id INT REFERENCES roles(role_id),
    permission_id INT REFERENCES permissions(permission_id),
    PRIMARY KEY (role_id, permission_id)
);

-- User-role relationship
CREATE TABLE user_roles (
    user_id INT REFERENCES users(user_id),
    role_id INT REFERENCES roles(role_id),
    granted_at TIMESTAMP DEFAULT NOW(),
    granted_by INT REFERENCES users(user_id),
    PRIMARY KEY (user_id, role_id)
);

-- No more anomalies!
-- Each role has consistent permissions
-- Complete audit trail of who granted what
```

---

## [RA] Question 7: Relational Algebra and Query Optimization

### Original Statement

> _"Consider the following relations of a relational database: A (A1, A2, A3) where A1 is the primary key, B (B1, B2, B3) where B1 is the primary key, AB (A1, B1) where A1 and B1 form the primary key. In table AB, both A1 and B1 are foreign keys that reference tables A and B, respectively. Elaborate a relational algebra expression that presents the values of A2 and B3 that are related, but only in cases where the value of A3 = 10. (1.0 point)"_

### Official Answer Key

```
π_{A2,B3} (σ_{A3=10} ((A ⋈ AB) ⋈ B))
```

### SQL Equivalent and Performance Analysis

```sql
-- SQL equivalent
SELECT DISTINCT A.A2, B.B3
FROM A
JOIN AB ON A.A1 = AB.A1
JOIN B ON AB.B1 = B.B1
WHERE A.A3 = 10;

-- Indexes needed for optimal performance
CREATE INDEX idx_a_a3_a1 ON A (A3, A1);   -- Covers WHERE and JOIN
CREATE INDEX idx_ab_a1_b1 ON AB (A1, B1); -- Composite for both joins
CREATE INDEX idx_b_b1 ON B (B1);          -- PK usually already indexed
```

### [!] Vulnerability: Join Bombing

**Scenario:** System allows custom queries with joins.

```python
# [X] VULNERABLE: No join limit
def custom_query(tables, conditions):
    joins = " JOIN ".join(tables)
    where = " AND ".join(conditions)
    
    query = f"SELECT * FROM {joins} WHERE {where}"
    return cursor.execute(query).fetchall()
```

**Attack: Cartesian Product DoS**

```python
# Attacker forces cartesian product
tables = ["A", "B", "A AS A2", "B AS B2", "A AS A3", "B AS B3"]
conditions = ["1=1"]

# Result: A×B×A×B×A×B = exponential explosion!
```

### [OK] Optimization and Protection

```python
# [+] Query optimizer with protections
def optimized_query(base_table, joins, filters):
    # 1. Join limit
    MAX_JOINS = 5
    if len(joins) > MAX_JOINS:
        raise ValueError(f"Maximum {MAX_JOINS} joins allowed")
    
    with connection.cursor() as cursor:
        # 2. Cost analysis via EXPLAIN
        test_query = build_query(base_table, joins, filters)
        cursor.execute(f"EXPLAIN (FORMAT JSON, BUFFERS) {test_query}")
        plan = cursor.fetchone()[0]
        
        estimated_cost = plan[0]['Plan']['Total Cost']
        estimated_rows = plan[0]['Plan']['Plan Rows']
        
        # Safety limits
        if estimated_cost > 10000:
            raise Exception(f"Query too complex (cost: {estimated_cost})")
        if estimated_rows > 1000000:
            raise Exception(f"Query would return too many rows: {estimated_rows}")
    
        # 3. Optimized query with timeouts
        cursor.execute("SET LOCAL statement_timeout = '2s'")
        cursor.execute("SET LOCAL work_mem = '16MB'")
        
        # Note: PostgreSQL doesn't support hints natively
        # Use proper indexes and updated statistics
        optimized_query = """
            SELECT A.A2, B.B3
            FROM A
            JOIN AB ON A.A1 = AB.A1
            JOIN B ON AB.B1 = B.B1  
            WHERE A.A3 = %s
            LIMIT 1000
        """
        
        cursor.execute(optimized_query, (filters,))
        return cursor.fetchall()
```

**Query Optimization Security Checklist:**

```
┌──────────────────────────────────────┐
│      JOIN SECURITY CHECKLIST         │
├──────────────────────────────────────┤
│ [ ] Maximum join limit (5)           │
│ [ ] EXPLAIN before execute           │
│ [ ] Statement timeout (2s)           │
│ [ ] Work memory limit (16MB)         │
│ [ ] Row limit (LIMIT/FETCH FIRST)    │
│ [ ] Indexes on all FKs               │
│ [ ] Slow query monitoring            │
│ [ ] Deny cross-db links              │
└──────────────────────────────────────┘
```

---

## [NF] Question 8: The Three Normal Forms and Security

### Original Statement

> _"What is the difference between first, second, and third normal form (1NF, 2NF, and 3NF) in database normalization and how can the correct application of these forms improve the efficiency and integrity of data in a database management system (DBMS)? (1.0 point)"_

### Normal Forms Explained

```
┌──────────────────────────────────────────────────┐
│              NORMAL FORMS                        │
├──────────────────────────────────────────────────┤
│ 1NF: Atomic values (no lists/arrays)             │
│      [OK] id | name | email                      │
│      [X]  id | name | emails[]                   │
│                                                  │
│ 2NF: 1NF + no partial dependencies               │
│      (all non-key depend on whole key)           │
│      [X] (order_id, product_id) → customer_name  │
│      [OK] order_id → customer_name               │
│                                                  │
│ 3NF: 2NF + no transitive dependencies            │
│      (non-key doesn't determine non-key)         │
│      [X] id → dept_id → dept_name                │
│      [OK] id → dept_id, dept_id → dept_name      │
│          (in separate tables)                    │
└──────────────────────────────────────────────────┘
```

### [X] Example of Denormalized Schema (Vulnerable)

```sql
-- [X] DENORMALIZED TABLE - SECURITY PROBLEMS
CREATE TABLE orders_denormalized (
    order_id INT PRIMARY KEY,
    customer_email VARCHAR(100),
    customer_password_hash VARCHAR(255),  -- NO!
    customer_address TEXT,
    product_ids TEXT,  -- "1,2,3" - violates 1NF!
    product_names TEXT,  -- "Mouse,Keyboard,Monitor"
    product_prices TEXT,  -- "50.00,100.00,500.00"
    total_amount DECIMAL(10,2),
    salesperson_id INT,
    salesperson_name VARCHAR(100),
    salesperson_commission DECIMAL(5,2)
);

-- PROBLEMS:
-- 1. Password duplicated in each order (mass leak)
-- 2. Arrays in strings (SQL injection via split)
-- 3. Redundancy (partial update)
-- 4. No referential integrity
```

**Possible Attacks:**

```sql
-- Attack 1: Mass Password Extraction
SELECT DISTINCT customer_email, customer_password_hash 
FROM orders_denormalized;
-- Leaks ALL passwords through orders table!

-- Attack 2: Price Manipulation via String
UPDATE orders_denormalized 
SET product_prices = '0.01,0.01,0.01'
WHERE order_id = 123;
-- Total not recalculated - fraud!

-- Attack 3: Commission Fraud
UPDATE orders_denormalized
SET salesperson_commission = 90.00
WHERE salesperson_id = 456;
-- Partial update - some orders at 90%, others not
```

### [OK] Normalized Schema (3NF) and Secure

```sql
-- [+] NORMALIZED AND SECURE SCHEMA

-- 1NF: Atomic values
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE customer_addresses (
    address_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id),
    address TEXT NOT NULL,
    is_default BOOLEAN DEFAULT FALSE
);

-- 2NF: No partial dependencies  
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    base_price DECIMAL(10,2) NOT NULL CHECK (base_price >= 0)
);

CREATE TABLE salespersons (
    salesperson_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    base_commission DECIMAL(5,2) CHECK (base_commission BETWEEN 0 AND 100)
);

-- 3NF: No transitive dependencies
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id),
    salesperson_id INT REFERENCES salespersons(salesperson_id),
    order_date TIMESTAMP DEFAULT NOW(),
    total_amount DECIMAL(10,2) DEFAULT 0  -- Maintained via trigger
);

CREATE TABLE order_items (
    order_id INT REFERENCES orders(order_id) ON DELETE CASCADE,
    product_id INT REFERENCES products(product_id),
    quantity INT NOT NULL CHECK (quantity > 0),
    unit_price DECIMAL(10,2) NOT NULL CHECK (unit_price >= 0),
    PRIMARY KEY (order_id, product_id)
);

-- Trigger to keep total_amount updated
CREATE OR REPLACE FUNCTION recalc_order_total() RETURNS trigger AS $
BEGIN
    UPDATE orders o
    SET total_amount = COALESCE((
        SELECT SUM(quantity * unit_price) 
        FROM order_items oi
        WHERE oi.order_id = COALESCE(NEW.order_id, OLD.order_id)
    ), 0)
    WHERE o.order_id = COALESCE(NEW.order_id, OLD.order_id);
    RETURN NULL;
END;
$ LANGUAGE plpgsql;

CREATE TRIGGER maintain_order_totals
AFTER INSERT OR UPDATE OR DELETE ON order_items
FOR EACH ROW EXECUTE FUNCTION recalc_order_total();

-- Views for easier queries
CREATE VIEW order_summary AS
SELECT 
    o.order_id,
    c.email,
    s.name as salesperson,
    o.total_amount,
    o.order_date
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
JOIN salespersons s ON o.salesperson_id = s.salesperson_id;

-- Row Level Security
ALTER TABLE customers ENABLE ROW LEVEL SECURITY;
CREATE POLICY customer_policy ON customers
    USING (customer_id = current_setting('app.current_user_id', true)::INT);

-- Note: Set the setting at session/transaction start:
-- SET LOCAL app.current_user_id = '123';
-- Use SET LOCAL for transaction scope only
```

**Normalization Advantages:**

```
┌──────────────────────────────────────────┐
│        SECURITY BENEFITS                 │
├──────────────────────────────────────────┤
│ • No duplication of sensitive data       │
│ • Guaranteed referential integrity       │
│ • Atomic and consistent updates          │
│ • Granular audit by table                │
│ • RLS applicable per entity              │
│ • Selective backup/restore               │
└──────────────────────────────────────────┘
```

---

## [*] Real Cases: When Aggregations and Normalization Fail

### Equifax Breach (2017)

The Equifax breach exposed data from 147 million people. One of the causes:

```
┌─────────────────────────────────────────┐
│           EQUIFAX DATA BREACH           │
├─────────────────────────────────────────┤
│ • Denormalized tables with PII          │
│ • SSN duplicated in multiple tables     │
│ • No segregation of sensitive data      │
│ • Aggregations without k-anonymity      │
│                                         │
│ RESULT: One SELECT * leaked everything  │
│ COST: $700 million in fines             │
└─────────────────────────────────────────┘
```

### NYC Taxi Dataset (2014)

Researchers re-identified celebrities and their trips:

```
┌────────────────────────────────────────────┐
│         NYC TAXI RE-IDENTIFICATION         │
├────────────────────────────────────────────┤
│ PROBLEM: MD5 hash of medallions            │
│ • Reversible via rainbow tables            │
│ • Joins with public events                 │
│ • Zone aggregations too specific           │
│                                            │
│ LESSON: k-anonymity + noise + no join keys │
└────────────────────────────────────────────┘
```

### Netflix Prize De-anonymization (2008)

Attackers linked "anonymous" ratings with public IMDb data:

```sql
-- How the attack worked (simplified):
SELECT netflix.user_id, imdb.username
FROM netflix_ratings n
JOIN imdb_public i 
  ON n.movie_id = i.movie_id 
  AND n.rating = i.rating
  AND ABS(n.date - i.date) < 14
GROUP BY netflix.user_id, imdb.username
HAVING COUNT(*) > 5;
-- Just 5-6 movies were enough to re-identify!
```

**Lesson:** Normalization isn't just about performance - it's about **minimizing the attack surface** and preventing fraud.

---

## [=] Best Practices: Secure Normalization

```
┌─────────────────────────────────────────────┐
│     NORMALIZATION SECURITY CHECKLIST v3.0   │
├─────────────────────────────────────────────┤
│                 DESIGN PHASE                │
│ [ ] Apply at least 3NF                      │
│ [ ] Separate PII into dedicated tables      │
│ [ ] Use views to denormalize                │
│ [ ] Implement computed columns              │
│                                             │
│              IMPLEMENTATION                 │
│ [ ] FK with appropriate ON DELETE/UPDATE    │
│ [ ] CHECK constraints on all fields         │
│ [ ] Indexes on all FKs                      │
│ [ ] Triggers to maintain consistency        │
│                                             │
│                SECURITY                     │
│ [ ] RLS per table                           │
│ [ ] Column-level encryption for PII         │
│ [ ] Separate audit log                      │
│ [ ] K-anonymity in aggregations             │
│ [ ] Data masking in development             │
└─────────────────────────────────────────────┘
```

---

## [>] Additional Resources

### Academic Literature

- Codd, E.F. (1970). "A Relational Model of Data for Large Shared Data Banks"
- Date, C.J. (2019). "Database Design and Relational Theory: Normal Forms and All That Jazz"
- Kent, W. (1983). "A Simple Guide to Five Normal Forms"

### Tools

- **SchemaSpy** - Documents and analyzes dependencies
- **Liquibase/Flyway** - Schema versioning
- **pgModeler** - Visual modeling with NF validation

### Standards

- ISO/IEC 9075 (SQL Standard)
- NIST 800-53 (Security Controls for Databases)

---

## [>>] Series Conclusion

Over three posts, we transformed academic questions into practical security lessons:

1. **Post 1:** [Schema design as first line of defense](/blog/post.html?id=BD-AP3-2025.1-q1)
2. **Post 2:** [The deadly trio UPDATE/DELETE/SELECT](/blog/post.html?id=BD-AP3-2025.1-q2-q4)
3. **Post 3:** Normalization and integrity against fraud

**Final message:** Database security isn't about adding firewall and encryption afterwards. It's about **designing correctly from the start**.

**Practice safely:**

- Test normalization concepts with [DB Fiddle](https://www.db-fiddle.com/)
- Experiment with GROUP BY protections using Docker PostgreSQL
- Read the original [AP3 exam](assets/BD-AP3-2025.1.pdf) for context and its [official answer key](assets/BD-AP3-2025.1-gabarito.pdf)

---

```
┌──────────────────────────────────────────────────┐
│ Author: Beatriz Costa                            | 
│ Series: Cybersecurity Lessons from UFF AP        |
│ Last updated: November 04, 2025                  |
│                                                  |
│ [EOF] End of File - Happy Hacking!               |
└──────────────────────────────────────────────────┘
```