```
 _   _  ___  ____  __  __    _    _     ___ _____  _  _____ ___ ___  _   _ 
| \ | |/ _ \|  _ \|  \/  |  / \  | |   |_ _|__  / / \|_   _|_ _/ _ \| \ | |
|  \| | | | | |_) | |\/| | / _ \ | |    | |  / / / _ \ | |  | | | | |  \| |
| |\  | |_| |  _ <| |  | |/ ___ \| |___ | | / /_/ ___ \| |  | | |_| | |\  |
|_| \_|\___/|_| \_\_|  |_/_/   \_\_____|___/____/_/   \_\_| |___\___/|_| \_|
                                                                              
 ____    _  _____  _       ___ _   _ _____ _____ ____ ____  ___ _______   __
|  _ \  / \|_   _|/ \     |_ _| \ | |_   _| ____/ ___|  _ \|_ _|_   _\ \ / /
| | | |/ _ \ | | / _ \     | ||  \| | | | |  _|| |  _| |_) || |  | |  \ V / 
| |_| / ___ \| |/ ___ \    | || |\  | | | | |__| |_| |  _ < | |  | |   | |  
|____/_/   \_\_/_/   \_\  |___|_| \_| |_| |_____\____|_| \_\___| |_|   |_|  
```

**Tempo de leitura:** 10 min | **Nível:** Intermediário/Avançado

**Tags:** `database-normalization` `functional-dependencies` `group-by-injection` `data-integrity` `relational-algebra` 

---

## [+] Introdução

Nos posts anteriores, vimos como criar schemas seguros e proteger queries básicas. Hoje mergulhamos nas **Questões 5-8 da AP3 2025.1**, explorando como **normalização inadequada** e **agregações mal protegidas** podem expor seu sistema a fraudes, inconsistências e ataques sofisticados.

**Spoiler:** Um GROUP BY mal configurado pode revelar salários de toda a empresa.

---

## [GROUP BY] Questão 5: Agregações e Vazamento de Dados

### Enunciado Original

> _"Considere a relação DOCENTE(SIAPE, NOME, UF, SALARIO, NIVEL) que armazena dados de docentes da UFF, onde SIAPE é a chave primária de DOCENTE. Apresente uma consulta em SQL que apresenta a média dos salários dos docentes por nível, mas somente quando a média for superior a 5.000 e os níveis forem ASSOCIADO e TITULAR. (1,0 ponto)"_

### Gabarito Oficial

```sql
SELECT nivel, AVG(salario) AS media_salarial
FROM DOCENTE
WHERE nivel IN ('ASSOCIADO', 'TITULAR')
GROUP BY nivel
HAVING AVG(salario) > 5000;
```

**Análise de Segurança:**

```
┌──────────────────────────────────┐
│     RISCOS DO GROUP BY              │
├──────────────────────────────────┤
│ • Inferência estatística             │
│ • Timing attacks em agregações      │
│ • Resource exhaustion (GROUP BY ALL)│
│ • Information disclosure via HAVING  │
└──────────────────────────────────┘
```

### [!] Vulnerabilidade: GROUP BY Information Disclosure

**Cenário:** Sistema permite consultas customizadas de RH.

```python
# [X] CÓDIGO VULNERÁVEL
def relatorio_salarial(niveis_selecionados, limite_media):
    query = f"""
        SELECT nivel, AVG(salario), COUNT(*) as total
        FROM DOCENTE
        WHERE nivel IN ({niveis_selecionados})
        GROUP BY nivel
        HAVING AVG(salario) > {limite_media}
    """
    return cursor.execute(query).fetchall()
```

**Ataque 1: Inferência de Salário Individual**

```python
# Atacante quebra o contexto da lista para adicionar condições
niveis = "'TITULAR') AND SIAPE = 12345 OR nivel IN ('TITULAR'"

# Query resultante:
"""
WHERE nivel IN ('TITULAR') AND SIAPE = 12345 OR nivel IN ('TITULAR')
"""
# Se COUNT(*) = 1, o AVG() revela o salário exato!
```

**Ataque 2: Resource Exhaustion**

```python
# Atacante força GROUP BY em campo com alta cardinalidade
niveis = "'TITULAR') GROUP BY SIAPE, NOME, UF, SALARIO --"

# Cria milhares de grupos, consumindo memória
```

**Ataque 3: Blind Injection via HAVING**

```python
# Atacante usa HAVING para extrair dados
limite_media = "5000 OR EXISTS (SELECT 1 FROM DOCENTE WHERE SALARIO > 100000)"

# Baseado no resultado, descobre se existe salário > 100k
```

### [OK] Correção: Agregações Seguras

```python
# [+] CÓDIGO SEGURO com proteções
def relatorio_salarial_seguro(niveis, limite_media):
    # 1. Whitelist de níveis
    niveis_validos = {'ASSOCIADO', 'TITULAR', 'ADJUNTO'}
    niveis_filtrados = [n for n in niveis if n in niveis_validos]
    
    # 2. Validação numérica
    if not isinstance(limite_media, (int, float)) or limite_media < 0:
        raise ValueError("Limite inválido")
    
    with connection.cursor() as cursor:
        # Configurações de segurança
        cursor.execute("BEGIN")
        cursor.execute("SET LOCAL statement_timeout = '2s'")
        cursor.execute("SET LOCAL work_mem = '16MB'")
        
        # 3. Proteção contra inferência - k-anonymity
        cursor.execute("""
            SELECT nivel, COUNT(*) as qtd 
            FROM DOCENTE 
            WHERE nivel = ANY(%s)
            GROUP BY nivel
        """, (niveis_filtrados,))
        
        counts = cursor.fetchall()
        valid_levels = []
        
        for nivel, qtd in counts:
            if qtd >= 10:  # k-anonymity threshold = 10
                valid_levels.append(nivel)
        
        # Regra: precisa de pelo menos 2 grupos válidos para evitar inferência
        if len(valid_levels) < 2:
            raise Exception("Dados insuficientes para garantir privacidade")
        
        # 4. Query parametrizada com proteções
        # ANY(%s) aceita array em PostgreSQL - evita concatenação
        query = """
            SELECT 
                nivel,
                ROUND(AVG(salario)::numeric, -2) as media_aproximada,  -- Arredonda centenas
                CASE 
                    WHEN COUNT(*) < 10 THEN '<10'
                    WHEN COUNT(*) BETWEEN 10 AND 50 THEN '10-50'
                    ELSE '50+'
                END as faixa_quantidade
            FROM DOCENTE
            WHERE nivel = ANY(%s)
            GROUP BY nivel
            HAVING AVG(salario) > %s AND COUNT(*) >= 10
            ORDER BY nivel
            LIMIT 100
        """
        
        cursor.execute(query, (valid_levels, limite_media))
        results = cursor.fetchall()
        cursor.execute("COMMIT")
        
        return results
```

**Proteções Implementadas:**

1. **K-anonymity (k=10):** Suprime grupos com menos de 10 registros
2. **Small-cell suppression:** Mínimo de 2 grupos válidos por consulta
3. **Statement timeout:** Limite de 2 segundos para execução
4. **Memory limit:** work_mem limitado a 16MB
5. **Arredondamento:** Médias arredondadas para prevenir inferência exata
6. **Parametrização:** ANY(%s) para arrays - nunca concatenação de strings

---

## [FD] Questão 6: Dependências Funcionais e Anomalias

### Enunciado Original

> _"Seja R(A,B,C) uma relação na 1FN. Sejam A, B e C atributos do tipo inteiro. Considere que o atributo A forme a chave primária de R. Informe uma possível instância de R (conjunto de tuplas de R), composta por apenas duas tuplas, que mostre que se A → B e A → C são dependências funcionais de R, então não necessariamente B → C também é uma dependência funcional de R. (1,0 ponto)"_

### Resposta com Análise de Segurança

```sql
-- Instância exemplo:
-- A | B | C
-- 1 | 50| 10
-- 2 | 50| 20

-- Análise:
-- A → B: OK (1→50, 2→50)
-- A → C: OK (1→10, 2→20) 
-- B → C: FALHA! (50→10 E 50→20)
```

### [!] Por Que Isso Importa para Segurança?

```
┌──────────────────────────────────────────┐
│        ANOMALIAS SEM NORMALIZAÇÃO        │
├──────────────────────────────────────────┤
│ INSERÇÃO:  Dados inconsistentes          │
│ ATUALIZAÇÃO: Mudanças parciais           │
│ DELEÇÃO: Perda não intencional de dados  │
│                                          │
│ RESULTADO: Bypass de regras de negócio   │
└──────────────────────────────────────────┘
```

**Exemplo Real: Sistema de Permissões**

```sql
-- [X] TABELA MAL NORMALIZADA
CREATE TABLE user_permissions (
    user_id INT,
    role VARCHAR(50),
    permission VARCHAR(100),
    department VARCHAR(50),
    PRIMARY KEY (user_id, permission)
);

-- Dados:
-- user_id | role    | permission      | department
-- 1       | admin   | delete_all      | IT
-- 2       | admin   | delete_all      | HR
-- 3       | viewer  | read_only       | IT

-- PROBLEMA: role → permission deveria ser uma DF
-- mas admin em IT tem permissões diferentes de admin em HR!
```

**Ataque: Privilege Escalation via Update Anomaly**

```sql
-- Atacante explora anomalia de atualização
UPDATE user_permissions 
SET role = 'admin' 
WHERE user_id = 3;

-- Agora user 3 é 'admin' mas mantém 'read_only'
-- Sistema confuso: é admin ou não?
```

### [OK] Solução: Normalização Adequada

```sql
-- [+] SCHEMA NORMALIZADO (3FN)

-- Tabela de usuários
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    department VARCHAR(50) NOT NULL
);

-- Tabela de roles
CREATE TABLE roles (
    role_id INT PRIMARY KEY,
    role_name VARCHAR(50) NOT NULL UNIQUE
);

-- Tabela de permissões
CREATE TABLE permissions (
    permission_id INT PRIMARY KEY,
    permission_name VARCHAR(100) NOT NULL UNIQUE
);

-- Relacionamento role-permission
CREATE TABLE role_permissions (
    role_id INT REFERENCES roles(role_id),
    permission_id INT REFERENCES permissions(permission_id),
    PRIMARY KEY (role_id, permission_id)
);

-- Relacionamento user-role
CREATE TABLE user_roles (
    user_id INT REFERENCES users(user_id),
    role_id INT REFERENCES roles(role_id),
    granted_at TIMESTAMP DEFAULT NOW(),
    granted_by INT REFERENCES users(user_id),
    PRIMARY KEY (user_id, role_id)
);

-- Agora não há anomalias!
-- Cada role tem permissões consistentes
-- Auditoria completa de quem concedeu o quê
```

---

## [RA] Questão 7: Álgebra Relacional e Query Optimization

### Enunciado Original

> _"Considere as seguintes relações de um banco de dados relacional: A (A1, A2, A3) onde A1 é chave primária, B (B1, B2, B3) onde B1 é chave primária, AB (A1, B1) onde A1 e B1 formam a chave primária. Na tabela AB, tanto A1 quanto B1 são chaves estrangeiras que referenciam as tabelas A e B, respectivamente. Elabore uma expressão da álgebra relacional que apresente os valores de A2 e B3 que estão relacionados, mas somente nos casos em que o valor de A3 = 10. (1,0 ponto)"_

### Gabarito Oficial

```
π_{A2,B3} (σ_{A3=10} ((A ⋈ AB) ⋈ B))
```

### SQL Equivalente e Análise de Performance

```sql
-- SQL equivalente
SELECT DISTINCT A.A2, B.B3
FROM A
JOIN AB ON A.A1 = AB.A1
JOIN B ON AB.B1 = B.B1
WHERE A.A3 = 10;

-- Índices necessários para performance ótima
CREATE INDEX idx_a_a3_a1 ON A (A3, A1);   -- Cobre WHERE e JOIN
CREATE INDEX idx_ab_a1_b1 ON AB (A1, B1); -- Composite para ambos os joins
CREATE INDEX idx_b_b1 ON B (B1);          -- PK geralmente já tem índice
```

### [!] Vulnerabilidade: Join Bombing

**Cenário:** Sistema permite queries customizadas com joins.

```python
# [X] VULNERÁVEL: Sem limite de joins
def consulta_customizada(tabelas, condicoes):
    joins = " JOIN ".join(tabelas)
    where = " AND ".join(condicoes)
    
    query = f"SELECT * FROM {joins} WHERE {where}"
    return cursor.execute(query).fetchall()
```

**Ataque: Cartesian Product DoS**

```python
# Atacante força produto cartesiano
tabelas = ["A", "B", "A AS A2", "B AS B2", "A AS A3", "B AS B3"]
condicoes = ["1=1"]

# Resultado: A×B×A×B×A×B = explosão exponencial!
```

### [OK] Otimização e Proteção

```python
# [+] Query optimizer com proteções
def consulta_otimizada(tabela_base, joins, filtros):
    # 1. Limite de joins
    MAX_JOINS = 5
    if len(joins) > MAX_JOINS:
        raise ValueError(f"Máximo {MAX_JOINS} joins permitidos")
    
    with connection.cursor() as cursor:
        # 2. Análise de custo via EXPLAIN
        test_query = build_query(tabela_base, joins, filtros)
        cursor.execute(f"EXPLAIN (FORMAT JSON, BUFFERS) {test_query}")
        plan = cursor.fetchone()[0]
        
        estimated_cost = plan[0]['Plan']['Total Cost']
        estimated_rows = plan[0]['Plan']['Plan Rows']
        
        # Limites de segurança
        if estimated_cost > 10000:
            raise Exception(f"Query muito complexa (custo: {estimated_cost})")
        if estimated_rows > 1000000:
            raise Exception(f"Query retornaria muitas linhas: {estimated_rows}")
    
        # 3. Query otimizada com timeouts
        cursor.execute("SET LOCAL statement_timeout = '2s'")
        cursor.execute("SET LOCAL work_mem = '16MB'")
        
        # Nota: PostgreSQL não suporta hints nativamente
        # Use índices apropriados e estatísticas atualizadas
        optimized_query = """
            SELECT A.A2, B.B3
            FROM A
            JOIN AB ON A.A1 = AB.A1
            JOIN B ON AB.B1 = B.B1  
            WHERE A.A3 = %s
            LIMIT 1000
        """
        
        cursor.execute(optimized_query, (filtros,))
        return cursor.fetchall()
```

**Query Optimization Security Checklist:**

```
┌──────────────────────────────────────┐
│      JOIN SECURITY CHECKLIST         │
├──────────────────────────────────────┤
│ [ ] Limite máximo de joins (5)       │
│ [ ] EXPLAIN antes de executar        │
│ [ ] Statement timeout (2s)           │
│ [ ] Work memory limit (16MB)         │
│ [ ] Row limit (LIMIT/FETCH FIRST)    │
│ [ ] Índices em todas as FKs          │
│ [ ] Monitor de slow queries          │
│ [ ] Negar cross-db links             │
└──────────────────────────────────────┘
```

---

## [NF] Questão 8: As Três Formas Normais e Segurança

### Enunciado Original

> _"Qual é a diferença entre a primeira, segunda e terceira forma normal (1FN, 2FN e 3FN) na normalização de banco de dados e como a aplicação correta dessas formas pode melhorar a eficiência e a integridade dos dados em um sistema de gerência de banco de dados (SGBD)? (1,0 ponto)"_

### As Formas Normais Explicadas

```
┌──────────────────────────────────────────────────┐
│              FORMAS NORMAIS                      │
├──────────────────────────────────────────────────┤
│ 1FN: Valores atômicos (sem listas/arrays)        │
│      [OK] id | nome | email                      │
│      [X]  id | nome | emails[]                   │
│                                                  │
│ 2FN: 1FN + sem dependências parciais             │
│      (todos não-chave dependem da chave toda)    │
│      [X] (order_id, product_id) → customer_name  │
│      [OK] order_id → customer_name               │
│                                                  │
│ 3FN: 2FN + sem dependências transitivas          │
│      (não-chave não determina não-chave)         │
│      [X] id → dept_id → dept_name                │
│      [OK] id → dept_id, dept_id → dept_name      │
│          (em tabelas separadas)                  │
└──────────────────────────────────────────────────┘
```

### [X] Exemplo de Schema Desnormalizado (Vulnerável)

```sql
-- [X] TABELA DESNORMALIZADA - PROBLEMAS DE SEGURANÇA
CREATE TABLE orders_denormalized (
    order_id INT PRIMARY KEY,
    customer_email VARCHAR(100),
    customer_password_hash VARCHAR(255),  -- NÃO!
    customer_address TEXT,
    product_ids TEXT,  -- "1,2,3" - viola 1FN!
    product_names TEXT,  -- "Mouse,Teclado,Monitor"
    product_prices TEXT,  -- "50.00,100.00,500.00"
    total_amount DECIMAL(10,2),
    salesperson_id INT,
    salesperson_name VARCHAR(100),
    salesperson_commission DECIMAL(5,2)
);

-- PROBLEMAS:
-- 1. Senha duplicada em cada pedido (vazamento em massa)
-- 2. Arrays em strings (SQL injection via split)
-- 3. Redundância (atualização parcial)
-- 4. Sem integridade referencial
```

**Ataques Possíveis:**

```sql
-- Ataque 1: Mass Password Extraction
SELECT DISTINCT customer_email, customer_password_hash 
FROM orders_denormalized;
-- Vaza TODAS as senhas através de tabela de pedidos!

-- Ataque 2: Price Manipulation via String
UPDATE orders_denormalized 
SET product_prices = '0.01,0.01,0.01'
WHERE order_id = 123;
-- Total não recalculado - fraude!

-- Ataque 3: Commission Fraud
UPDATE orders_denormalized
SET salesperson_commission = 90.00
WHERE salesperson_id = 456;
-- Atualização parcial - alguns pedidos com 90%, outros não
```

### [OK] Schema Normalizado (3FN) e Seguro

```sql
-- [+] SCHEMA NORMALIZADO E SEGURO

-- 1FN: Valores atômicos
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE customer_addresses (
    address_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id),
    address TEXT NOT NULL,
    is_default BOOLEAN DEFAULT FALSE
);

-- 2FN: Sem dependências parciais  
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    base_price DECIMAL(10,2) NOT NULL CHECK (base_price >= 0)
);

CREATE TABLE salespersons (
    salesperson_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    base_commission DECIMAL(5,2) CHECK (base_commission BETWEEN 0 AND 100)
);

-- 3FN: Sem dependências transitivas
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id),
    salesperson_id INT REFERENCES salespersons(salesperson_id),
    order_date TIMESTAMP DEFAULT NOW(),
    total_amount DECIMAL(10,2) DEFAULT 0  -- Mantido via trigger
);

CREATE TABLE order_items (
    order_id INT REFERENCES orders(order_id) ON DELETE CASCADE,
    product_id INT REFERENCES products(product_id),
    quantity INT NOT NULL CHECK (quantity > 0),
    unit_price DECIMAL(10,2) NOT NULL CHECK (unit_price >= 0),
    PRIMARY KEY (order_id, product_id)
);

-- Trigger para manter total_amount atualizado
CREATE OR REPLACE FUNCTION recalc_order_total() RETURNS trigger AS $
BEGIN
    UPDATE orders o
    SET total_amount = COALESCE((
        SELECT SUM(quantity * unit_price) 
        FROM order_items oi
        WHERE oi.order_id = COALESCE(NEW.order_id, OLD.order_id)
    ), 0)
    WHERE o.order_id = COALESCE(NEW.order_id, OLD.order_id);
    RETURN NULL;
END;
$ LANGUAGE plpgsql;

CREATE TRIGGER maintain_order_totals
AFTER INSERT OR UPDATE OR DELETE ON order_items
FOR EACH ROW EXECUTE FUNCTION recalc_order_total();

-- Views para facilitar consultas
CREATE VIEW order_summary AS
SELECT 
    o.order_id,
    c.email,
    s.name as salesperson,
    o.total_amount,
    o.order_date
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
JOIN salespersons s ON o.salesperson_id = s.salesperson_id;

-- Row Level Security
ALTER TABLE customers ENABLE ROW LEVEL SECURITY;
CREATE POLICY customer_policy ON customers
    USING (customer_id = current_setting('app.current_user_id', true)::INT);

-- Nota: Configure o setting no início da sessão/transação:
-- SET LOCAL app.current_user_id = '123';
-- Use SET LOCAL para escopo de transação apenas
```

**Vantagens da Normalização:**

```
┌──────────────────────────────────────────┐
│      BENEFÍCIOS DE SEGURANÇA             │
├──────────────────────────────────────────┤
│ • Sem duplicação de dados sensíveis      │
│ • Integridade referencial garantida      │
│ • Atualizações atômicas e consistentes   │
│ • Auditoria granular por tabela          │
│ • RLS aplicável por entidade             │
│ • Backup/restore seletivo                │
└──────────────────────────────────────────┘
```

---

## [*] Casos Reais: Quando Agregações e Normalização Falham

### Equifax Breach (2017)

O vazamento da Equifax expôs dados de 147 milhões de pessoas. Uma das causas:

```
┌─────────────────────────────────────────┐
│           EQUIFAX DATA BREACH           │
├─────────────────────────────────────────┤
│ • Tabelas desnormalizadas com PII       │
│ • SSN duplicado em múltiplas tabelas    │
│ • Sem segregação de dados sensíveis     │
│ • Agregações sem k-anonymity            │
│                                         │
│ RESULTADO: Um SELECT * vazou tudo       │
│ CUSTO: $700 milhões em multas           │
└─────────────────────────────────────────┘
```

### NYC Taxi Dataset (2014)

Pesquisadores re-identificaram celebridades e seus trajetos:

```
┌────────────────────────────────────────────┐
│         NYC TAXI RE-IDENTIFICATION         │
├────────────────────────────────────────────┤
│ PROBLEMA: Hash MD5 de medallions           │
│ • Reversível via rainbow tables            │
│ • Joins com eventos públicos               │
│ • Agregações por zona muito específicas    │
│                                            │
│ LIÇÃO: k-anonymity + noise + no join keys  │
└────────────────────────────────────────────┘
```

### Netflix Prize De-anonymization (2008)

Atacantes linkaram ratings "anônimos" com dados públicos do IMDb:

```sql
-- Como o ataque funcionou (simplificado):
SELECT netflix.user_id, imdb.username
FROM netflix_ratings n
JOIN imdb_public i 
  ON n.movie_id = i.movie_id 
  AND n.rating = i.rating
  AND ABS(n.date - i.date) < 14
GROUP BY netflix.user_id, imdb.username
HAVING COUNT(*) > 5;
-- Bastavam 5-6 filmes para re-identificar!
```

**Lição:** Normalização não é apenas sobre performance - é sobre **minimizar a superfície de ataque** e prevenir fraudes.

---

## [=] Best Practices: Normalização Segura

```
┌─────────────────────────────────────────────┐
│     NORMALIZATION SECURITY CHECKLIST v3.0   │
├─────────────────────────────────────────────┤
│                 DESIGN PHASE                │
│ [ ] Aplicar no mínimo 3FN                   │
│ [ ] Separar PII em tabelas dedicadas        │
│ [ ] Usar views para desnormalizar           │
│ [ ] Implementar computed columns            │
│                                             │
│              IMPLEMENTATION                 │
│ [ ] FK com ON DELETE/UPDATE apropriado      │
│ [ ] CHECK constraints em todos os campos    │
│ [ ] Índices em todas as FKs                 │
│ [ ] Triggers para manter consistência       │
│                                             │
│                SECURITY                     │
│ [ ] RLS por tabela                          │
│ [ ] Criptografia column-level para PII      │
│ [ ] Audit log separado                      │
│ [ ] K-anonymity em agregações               │
│ [ ] Data masking em desenvolvimento         │
└─────────────────────────────────────────────┘
```

---

## [>] Recursos Adicionais

### Literatura Acadêmica

- Codd, E.F. (1970). "A Relational Model of Data for Large Shared Data Banks"
- Date, C.J. (2019). "Database Design and Relational Theory: Normal Forms and All That Jazz"
- Kent, W. (1983). "A Simple Guide to Five Normal Forms"

### Ferramentas

- **SchemaSpy** - Documenta e analisa dependências
- **Liquibase/Flyway** - Versionamento de schema
- **pgModeler** - Modelagem visual com validação de FN

### Standards

- ISO/IEC 9075 (SQL Standard)
- NIST 800-53 (Security Controls for Databases)

---

## [>>] Conclusão da Série

Ao longo de três posts, transformamos questões acadêmicas em lições práticas de segurança:

1. **Post 1:** [Schema design como primeira linha de defesa](/blog/post.html?id=BD-AP3-2025.1-q1)
2. **Post 2:** [O trio mortal UPDATE/DELETE/SELECT](/blog/post.html?id=BD-AP3-2025.1-q2-q4)
3. **Post 3:** Normalização e integridade contra fraudes

**Mensagem final:** Segurança de banco de dados não é adicionar firewall e criptografia depois. É **projetar corretamente desde o início**.

**Pratique com segurança:**

- Teste conceitos de normalização com [DB Fiddle](https://www.db-fiddle.com/)
- Experimente proteções de GROUP BY usando Docker PostgreSQL
- Leia a [prova AP3 original](assets/BD-AP3-2025.1.pdf) para contexto e seu [gabarito oficial](assets/BD-AP3-2025.1-gabarito.pdf)

---

```
┌──────────────────────────────────────────────────┐
│ Autor: Beatriz Costa                             │
│ Série: Cybersecurity Lessons from UFF AP         │
│ Última atualização: 04 de novembro de 2025       │
│                                                  │
│ [EOF] End of File - Happy Hacking!               │
└──────────────────────────────────────────────────┘
```