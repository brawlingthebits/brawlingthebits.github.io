```
 ____   ____ _   _ _____ __  __    _    
/ ___| |  _ \ | | | ____|  \/  |  / \   
\___ \ | |_) | |_| |  _| | |\/| | / _ \  
 ___) |  __/|  _  | |___| |  | |/ ___ \ 
|____/|_|   |_| |_|_____|_|  |_/_/   \_\
                                         
 ____  _____ ____ _   _ ____  ___ _______   __
/ ___|| ____/ ___| | | |  _ \|_ _|_   _\ \ / /
\___ \|  _|| |   | | | | |_) || |  | |  \ V / 
 ___) | |__| |___| |_| |  _ < | |  | |   | |  
|____/|_____\____|\___/|_| \_\___| |_|   |_|  
```

**Tempo de leitura:** 7-9 min | **Nível:** Iniciante/Intermediário

**Tags:** `database-security` `sql-security` `schema-design` `postgresql` `cybersecurity` `ap3-uff`

---

## [+] Introdução

A forma como você cria tabelas SQL pode ser a diferença entre um sistema seguro e um vazamento milionário. Neste post analisamos a **Questão 1 da AP3 2025.1 (UFF)**, que pede um schema para gerenciar **Ensembles de Machine Learning** - e transformamos o enunciado em um guia de **segurança de dados**.

---

## [+] Contexto da Questão

**Esquema lógico fornecido:**

```sql
USUARIO(uid, unome, ulogin, uprovedor, uIP, país)
ALGORITMO(aid, titulo, categoria, tipo, ano)
ENSEMBLE(eid, uid, data_submissao, hora_submissao, num_epocas, 
         tamanho_batch, taxa_aprendizado)
MODELO(eid, aid, acuracia, precisao)
```

Por que importa? Há dados sensíveis (logins, IPs) e **propriedade intelectual** (configurações/métricas de modelos). O schema é a **primeira linha de defesa**.

---

## [>] Versão Base (gabarito simplificado)

> Boa para começar, **insuficiente** para produção.

```sql
CREATE TABLE USUARIO (
  uid INT PRIMARY KEY,
  unome VARCHAR(100),
  ulogin VARCHAR(50),
  uprovedor VARCHAR(50),
  uIP VARCHAR(45),
  pais VARCHAR(50)
);

CREATE TABLE ALGORITMO (
  aid INT PRIMARY KEY,
  titulo VARCHAR(100),
  categoria VARCHAR(50),
  tipo VARCHAR(50),
  ano INT
);

CREATE TABLE ENSEMBLE (
  eid INT PRIMARY KEY,
  uid INT,
  data_submissao DATE,
  hora_submissao TIME,
  num_epocas INT,
  tamanho_batch INT,
  taxa_aprendizado DECIMAL(5,4),
  FOREIGN KEY (uid) REFERENCES USUARIO(uid)
);

CREATE TABLE MODELO (
  eid INT,
  aid INT,
  acuracia DECIMAL(5,4),
  precisao DECIMAL(5,4),
  PRIMARY KEY (eid, aid),
  FOREIGN KEY (eid) REFERENCES ENSEMBLE(eid),
  FOREIGN KEY (aid) REFERENCES ALGORITMO(aid)
);
```

---

## [>>] Versão Hardened (produção)

```
┌─────────────────────────────────────┐
│  PRINCIPAIS MUDANÇAS DE SEGURANÇA   │
├─────────────────────────────────────┤
│ • inet para IP (validação nativa)   │
│ • citext para login case-insensitive│
│ • timestamptz para timezone-aware   │
│ • IDENTITY ao invés de SERIAL       │
│ • Domínio percent_0_1 para métricas │
│ • país como CHAR(2) ISO-3166        │
│ • NOT NULL + CHECK consistentes     │
│ • Índices otimizados                │
│ • Triggers de auditoria             │
│ • RLS opcional (multi-tenant)       │
└─────────────────────────────────────┘
```

```sql
-- Extensões úteis
CREATE EXTENSION IF NOT EXISTS citext;

-- Domínio para métricas [0,1]
CREATE DOMAIN percent_0_1 AS numeric(5,4)
  CHECK (VALUE >= 0 AND VALUE <= 1);

-- USUARIOS
CREATE TABLE usuario (
  uid        BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  unome      varchar(100) NOT NULL CHECK (char_length(unome) >= 3),
  ulogin     citext NOT NULL UNIQUE CHECK (ulogin ~ '^[a-z0-9_]{3,50}$'),
  uprovedor  varchar(50) NOT NULL,
  uip        inet NOT NULL,
  pais       char(2) NOT NULL CHECK (pais ~ '^[A-Z]{2}$'),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- ALGORITMOS
CREATE TABLE algoritmo (
  aid        BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  titulo     varchar(100) NOT NULL UNIQUE,
  categoria  text NOT NULL
    CHECK (categoria IN ('supervisionado','nao-supervisionado','reforco')),
  tipo       varchar(50) NOT NULL,
  ano        smallint NOT NULL
    CHECK (ano BETWEEN 1950 AND EXTRACT(YEAR FROM now())::int),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- ENSEMBLES
CREATE TABLE ensemble (
  eid              BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  uid              BIGINT NOT NULL REFERENCES usuario(uid) ON DELETE CASCADE,
  submitted_at     timestamptz NOT NULL DEFAULT now(),
  num_epocas       int NOT NULL CHECK (num_epocas BETWEEN 1 AND 10000),
  tamanho_batch    int NOT NULL CHECK (tamanho_batch BETWEEN 1 AND 10000),
  taxa_aprendizado percent_0_1 NOT NULL,
  created_at       timestamptz NOT NULL DEFAULT now(),
  updated_at       timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS ix_ensemble_uid          ON ensemble(uid);
CREATE INDEX IF NOT EXISTS ix_ensemble_submitted_at ON ensemble(submitted_at);

-- MODELOS
CREATE TABLE modelo (
  eid        BIGINT NOT NULL REFERENCES ensemble(eid)  ON DELETE CASCADE,
  aid        BIGINT NOT NULL REFERENCES algoritmo(aid) ON DELETE RESTRICT,
  acuracia   percent_0_1,
  precisao   percent_0_1,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (eid, aid)
);

CREATE INDEX IF NOT EXISTS ix_modelo_aid ON modelo(aid);

-- Atualização automática de updated_at
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END; $$;

CREATE TRIGGER tg_usuario_upd   BEFORE UPDATE ON usuario  FOR EACH ROW EXECUTE FUNCTION set_updated_at();
CREATE TRIGGER tg_algoritmo_upd BEFORE UPDATE ON algoritmo FOR EACH ROW EXECUTE FUNCTION set_updated_at();
CREATE TRIGGER tg_ensemble_upd  BEFORE UPDATE ON ensemble  FOR EACH ROW EXECUTE FUNCTION set_updated_at();
CREATE TRIGGER tg_modelo_upd    BEFORE UPDATE ON modelo    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- (Opcional) RLS: cada usuário vê seus próprios ensembles/modelos
ALTER TABLE ensemble ENABLE ROW LEVEL SECURITY;
ALTER TABLE modelo   ENABLE ROW LEVEL SECURITY;

CREATE POLICY ensemble_owner
  ON ensemble
  USING (uid = current_setting('app.current_uid', true)::bigint)
  WITH CHECK (uid = current_setting('app.current_uid', true)::bigint);

CREATE POLICY modelo_owner
  ON modelo
  USING (EXISTS (
    SELECT 1 FROM ensemble e
    WHERE e.eid = modelo.eid
      AND e.uid = current_setting('app.current_uid', true)::bigint
  ));
```

> **[!]** Índices melhoram performance e ajudam a resiliência sob carga, mas **não são** controle anti-DoS por si só. Combine com rate limiting, circuit breakers e timeouts.

---

## [-] "Mas eu uso Django/ORM..."

Ótimo - mas **validação no app não substitui constraints no banco**.

### Model com validação de app E base de dados

```python
# models.py
from django.db import models
from django.core.validators import RegexValidator, MinLengthValidator
from django.contrib.postgres.fields import CICharField  # -> citext

class Usuario(models.Model):
    unome = models.CharField(max_length=100, validators=[MinLengthValidator(3)])
    ulogin = CICharField(
        max_length=50,
        unique=True,
        validators=[RegexValidator(r'^[a-z0-9_]{3,50}$', message='Login inválido')]
    )
    uIP = models.GenericIPAddressField(protocol='both', unpack_ipv4=True)
    pais = models.CharField(max_length=2)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
```

**Migration de hardening (DB-level):**

```python
# migrations/0002_db_constraints.py
from django.db import migrations

HARDEN = """
CREATE EXTENSION IF NOT EXISTS citext;
ALTER TABLE app_usuario
  ALTER COLUMN "uIP"  TYPE inet USING "uIP"::inet,
  ALTER COLUMN "pais" TYPE char(2) USING upper("pais");
ALTER TABLE app_usuario
  ADD CONSTRAINT chk_unome_len CHECK (char_length("unome") >= 3),
  ADD CONSTRAINT chk_pais_code CHECK ("pais" ~ '^[A-Z]{2}$');
"""

REVERT = """
ALTER TABLE app_usuario DROP CONSTRAINT IF EXISTS chk_unome_len;
ALTER TABLE app_usuario DROP CONSTRAINT IF EXISTS chk_pais_code;
-- (Reverter tipos apenas se necessário)
"""

class Migration(migrations.Migration):
    dependencies = [('app', '0001_initial')]
    operations = [migrations.RunSQL(HARDEN, REVERT)]
```

> **[OK]** Defense in depth: ORM valida para UX e regras de negócio; o banco **garante** o mínimo aceitável contra bypass (raw SQL, jobs legados, acessos diretos).

---

## [X] Ataques Éticos

### 1) Entrada sem limites → Oversized payload / DoS

**Sintoma:** `VARCHAR` sem limite + sem validação no app.

```sql
CREATE TABLE usuario_vuln (
  uid BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  unome varchar,  -- sem limite
  ulogin varchar,
  uip    text
);

INSERT INTO usuario_vuln(unome, ulogin, uip)
VALUES (repeat('A', 1000000), 'attacker', '192.168.1.1');
```

**Impacto:** memória/disco, vacuums caros, slow scans.  
**Correção:** limites de tamanho + validação no app.

### 2) SQL Injection (root cause = concatenação de strings)

Constraints não param SQLi; **apenas parametrização** para. Use prepared statements, ORM, bind parameters. Mantenha constraints para **qualidade de dados**.

### 3) Campos críticos nulos

Defina `NOT NULL` e defaults corretos; evite usuários/ensembles "fantasmas".

### 4) Referências órfãs

Sempre `FOREIGN KEY` com política adequada (`CASCADE`, `RESTRICT`).

---

## [=] Checklist de Segurança do Schema

```
┌──────────────────────────────────────┐
│  SCHEMA SECURITY CHECKLIST v1.0      │
├──────────────────────────────────────┤
│ [ ] Tipos corretos (inet, citext)    │
│ [ ] NOT NULL nos campos essenciais   │
│ [ ] CHECK (ranges, regex, ISO-3166)  │
│ [ ] VARCHAR com tamanhos apropriados │
│ [ ] FK com política ON DELETE        │
│ [ ] Índices para joins e filtros     │
│ [ ] Auditoria (created_at/updated_at)│
│ [ ] RLS/Privilégios por papel/tenant │
│ [ ] Comentários (COMMENT ON) docs    │
└──────────────────────────────────────┘
```

---

## [>] Recursos Adicionais

### Documentação

- [PostgreSQL: CREATE TABLE](https://www.postgresql.org/docs/current/sql-createtable.html)
- [PostgreSQL: Tipos de Dados](https://www.postgresql.org/docs/current/datatype.html)
- [PostgreSQL: Constraints](https://www.postgresql.org/docs/current/ddl-constraints.html)

### Padrões de Segurança

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [CWE-89: SQL Injection](https://cwe.mitre.org/data/definitions/89.html)

### Livros

- "SQL Antipatterns" por Bill Karwin
- "Database Reliability Engineering" por Laine Campbell & Charity Majors

---

## [>>] Próximos Passos

**Próximo da série:** [Post 2 - O Trio Mortal: UPDATE, DELETE, SELECT](/blog/post.html?id=BD-AP3-2025.1-q2-q4)

**Pratique com segurança:**

- Use [DB Fiddle](https://www.db-fiddle.com/) para testar schemas PostgreSQL
- Experimente [SQLFiddle](http://sqlfiddle.com/) para testar constraints
- Configure PostgreSQL local com Docker: `docker run -p 5432:5432 postgres:16`
- Leia a [prova AP3 original](assets/BD-AP3-2025.1.pdf) para contexto e seu [gabarito oficial](assets/BD-AP3-2025.1-gabarito.pdf)

---

```
┌──────────────────────────────────────────────────┐
│ Autor: Beatriz Costa                             │
│ Série: Cybersecurity Lessons from UFF AP         │
│ Última atualização: 04 de novembro de 2025       │
│                                                  │
│ [!] Apenas para fins educacionais                │
└──────────────────────────────────────────────────┘
```